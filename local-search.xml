<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SpringMvc源码分析6——HandlerMethodReturnValueHandler</title>
    <link href="/2020/02/28/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906%E2%80%94%E2%80%94HandlerMethodReturnValueHandler/"/>
    <url>/2020/02/28/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%906%E2%80%94%E2%80%94HandlerMethodReturnValueHandler/</url>
    
    <content type="html"><![CDATA[<p>回到<a href="/2020/02/26/SpringMvc源码分析5.1——HandlerMethodArgumentResolver/" title="SpringMvc源码分析5.1——HandlerMethodArgumentResolver">SpringMvc源码分析5.1——HandlerMethodArgumentResolver</a>的源码分析<code>ServletInvocableHandlerMethod#invokeAndHandle(..)</code>：</p><pre><code class="java">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,      Object... providedArgs) throws Exception {   // 重点，从请求上下文中解析出参数值，然后调用方法   Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);   // 设置响应状态   setResponseStatus(webRequest);   if (returnValue == null) {      if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {         disableContentCachingIfNecessary(webRequest);         mavContainer.setRequestHandled(true);         return;      }   }   else if (StringUtils.hasText(getResponseStatusReason())) {      mavContainer.setRequestHandled(true);      return;   }   mavContainer.setRequestHandled(false);   Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);   try {      // 重点关注，调用匹配的HandlerMethodReturnValueHandler      this.returnValueHandlers.handleReturnValue(            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);   }   catch (Exception ex) {      if (logger.isTraceEnabled()) {         logger.trace(formatErrorForReturnValue(returnValue), ex);      }      throw ex;   }}</code></pre><p>对于参数解析的那一块我们前面已经分析过，所以我们接着分析<code>handleReturnValue(..)</code>返回值处理这一块。</p><h3 id="一-源码分析"><a href="#一-源码分析" class="headerlink" title="一. 源码分析"></a>一. 源码分析</h3><blockquote><p> 追踪一下 <code>this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest)</code>方法</p></blockquote><pre><code class="java">public void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,            ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {    // 遍历找到支持的HandlerMethodReturnValueHandler        HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);        if (handler == null) {            throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());        }        handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);    }</code></pre><p>遍历已经注册的<code>HandlerMethodReturnValueHandler</code>，找到匹配的并执行它的<code>handleReturnValue(..)</code>。</p><p>首先我们看一下已经注册的<code>HandlerMethodReturnValueHandler</code>：</p><p><img src="/2020/02/28/SpringMvc源码分析6——HandlerMethodReturnValueHandler/returnValueHandlers.jpg" srcset="/img/loading.gif" alt="returnValueHandlers"></p><p>然后看一下<code>HandlerMethodReturnValueHandler</code>的接口定义：</p><pre><code class="java">public interface HandlerMethodReturnValueHandler {   /**    * Whether the given {@linkplain MethodParameter method return type} is    * supported by this handler.    * @param returnType the method return type to check    * @return {@code true} if this handler supports the supplied return type;    * {@code false} otherwise    */   boolean supportsReturnType(MethodParameter returnType);   /**    * Handle the given return value by adding attributes to the model and    * setting a view or setting the    * {@link ModelAndViewContainer#setRequestHandled} flag to {@code true}    * to indicate the response has been handled directly.    * @param returnValue the value returned from the handler method    * @param returnType the type of the return value. This type must have    * previously been passed to {@link #supportsReturnType} which must    * have returned {@code true}.    * @param mavContainer the ModelAndViewContainer for the current request    * @param webRequest the current request    * @throws Exception if the return value handling results in an error    */   void handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,         ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;}</code></pre><blockquote><p>策略接口，用于处理从<code>handler</code>方法调用返回的值。</p></blockquote><p>接口的实现：</p><p><img src="/2020/02/28/SpringMvc源码分析6——HandlerMethodReturnValueHandler/HandlerMethodReturnValueHandler.jpg" srcset="/img/loading.gif" alt="HandlerMethodReturnValueHandler"></p><p>这些策略实现，使的程序方便的处理各种返回值，比如<code>String</code>，<code>ModelAndView</code>，<code>Map</code>,<code>HttpEntity</code>，<code>@RequestBody</code>注解等等。那我<code>SpringMvc</code>支持那些返回值呢,看一下<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments" target="_blank" rel="noopener">官方文档</a>:</p><table><thead><tr><th style="text-align:left">Controller method return value</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>@ResponseBody</code></td><td style="text-align:left">The return value is converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-responsebody" target="_blank" rel="noopener"><code>@ResponseBody</code></a>.</td></tr><tr><td style="text-align:left"><code>HttpEntity</code>, <code>ResponseEntity</code></td><td style="text-align:left">The return value that specifies the full response (including HTTP headers and body) is to be converted through <code>HttpMessageConverter</code> implementations and written to the response. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-responseentity" target="_blank" rel="noopener">ResponseEntity</a>.</td></tr><tr><td style="text-align:left"><code>HttpHeaders</code></td><td style="text-align:left">For returning a response with headers and no body.</td></tr><tr><td style="text-align:left"><code>String</code></td><td style="text-align:left">A view name to be resolved with <code>ViewResolver</code> implementations and used together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration" target="_blank" rel="noopener">Explicit Registrations</a>).</td></tr><tr><td style="text-align:left"><code>View</code></td><td style="text-align:left">A <code>View</code> instance to use for rendering together with the implicit model — determined through command objects and <code>@ModelAttribute</code> methods. The handler method can also programmatically enrich the model by declaring a <code>Model</code> argument (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-registration" target="_blank" rel="noopener">Explicit Registrations</a>).</td></tr><tr><td style="text-align:left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code></td><td style="text-align:left">Attributes to be added to the implicit model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.</td></tr><tr><td style="text-align:left"><code>@ModelAttribute</code></td><td style="text-align:left">An attribute to be added to the model, with the view name implicitly determined through a <code>RequestToViewNameTranslator</code>.Note that <code>@ModelAttribute</code> is optional. See “Any other return value” at the end of this table.</td></tr><tr><td style="text-align:left"><code>ModelAndView</code> object</td><td style="text-align:left">The view and model attributes to use and, optionally, a response status.</td></tr><tr><td style="text-align:left"><code>void</code></td><td style="text-align:left">A method with a <code>void</code> return type (or <code>null</code> return value) is considered to have fully handled the response if it also has a <code>ServletResponse</code>, an <code>OutputStream</code> argument, or an <code>@ResponseStatus</code> annotation. The same is also true if the controller has made a positive <code>ETag</code> or <code>lastModified</code> timestamp check (see <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-caching-etag-lastmodified" target="_blank" rel="noopener">Controllers</a> for details).If none of the above is true, a <code>void</code> return type can also indicate “no response body” for REST controllers or a default view name selection for HTML controllers.</td></tr><tr><td style="text-align:left"><code>DeferredResult</code></td><td style="text-align:left">Produce any of the preceding return values asynchronously from any thread — for example, as a result of some event or callback. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-deferredresult" target="_blank" rel="noopener"><code>DeferredResult</code></a>.</td></tr><tr><td style="text-align:left"><code>Callable</code></td><td style="text-align:left">Produce any of the above return values asynchronously in a Spring MVC-managed thread. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-callable" target="_blank" rel="noopener"><code>Callable</code></a>.</td></tr><tr><td style="text-align:left"><code>ListenableFuture</code>, <code>java.util.concurrent.CompletionStage</code>, <code>java.util.concurrent.CompletableFuture</code></td><td style="text-align:left">Alternative to <code>DeferredResult</code>, as a convenience (for example, when an underlying service returns one of those).</td></tr><tr><td style="text-align:left"><code>ResponseBodyEmitter</code>, <code>SseEmitter</code></td><td style="text-align:left">Emit a stream of objects asynchronously to be written to the response with <code>HttpMessageConverter</code> implementations. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming" target="_blank" rel="noopener">HTTP Streaming</a>.</td></tr><tr><td style="text-align:left"><code>StreamingResponseBody</code></td><td style="text-align:left">Write to the response <code>OutputStream</code> asynchronously. Also supported as the body of a <code>ResponseEntity</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-http-streaming" target="_blank" rel="noopener">HTTP Streaming</a>.</td></tr><tr><td style="text-align:left">Reactive types — Reactor, RxJava, or others through <code>ReactiveAdapterRegistry</code></td><td style="text-align:left">Alternative to <code>DeferredResult</code> with multi-value streams (for example, <code>Flux</code>, <code>Observable</code>) collected to a <code>List</code>.For streaming scenarios (for example, <code>text/event-stream</code>, <code>application/json+stream</code>), <code>SseEmitter</code> and <code>ResponseBodyEmitter</code> are used instead, where <code>ServletOutputStream</code> blocking I/O is performed on a Spring MVC-managed thread and back pressure is applied against the completion of each write.See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async" target="_blank" rel="noopener">Asynchronous Requests</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-async-reactive-types" target="_blank" rel="noopener">Reactive Types</a>.</td></tr><tr><td style="text-align:left">Any other return value</td><td style="text-align:left">Any return value that does not match any of the earlier values in this table and that is a <code>String</code> or <code>void</code> is treated as a view name (default view name selection through <code>RequestToViewNameTranslator</code> applies), provided it is not a simple type, as determined by <a href="https://docs.spring.io/spring-framework/docs/5.2.4.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-" target="_blank" rel="noopener">BeanUtils#isSimpleProperty</a>. Values that are simple types remain unresolved.</td></tr></tbody></table><p>官方文档列的也比较详细，但是有一点还是有必要说明一下，就是当使用<code>@ResponseBody</code>，<code>HttpEntity</code>, <code>ResponseEntity</code>时候，我们可以利用<code>ResponseBodyAdvice</code>在<code>HttpMessageConverter#write(..)</code>前做一些小处理，源码位置在<code>AbstractMessageConverterMethodProcessor#writeWithMessageConverters(T, org.springframework.core.MethodParameter, org.springframework.http.server.ServletServerHttpRequest, org.springframework.http.server.ServletServerHttpResponse)</code>:</p><pre><code class="java">...  for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {    GenericHttpMessageConverter genericConverter = (converter instanceof GenericHttpMessageConverter ?                                                    (GenericHttpMessageConverter&lt;?&gt;) converter : null);    if (genericConverter != null ?        ((GenericHttpMessageConverter) converter).canWrite(targetType, valueType, selectedMediaType) :        converter.canWrite(valueType, selectedMediaType)) {      // 利用ResponseBodyAdvice做一些提前处理      body = getAdvice().beforeBodyWrite(body, returnType, selectedMediaType,                                         (Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt;) converter.getClass(),                                         inputMessage, outputMessage);      if (body != null) {        Object theBody = body;        LogFormatUtils.traceDebug(logger, traceOn -&gt;                                  &quot;Writing [&quot; + LogFormatUtils.formatValue(theBody, !traceOn) + &quot;]&quot;);        addContentDispositionHeader(inputMessage, outputMessage);        if (genericConverter != null) {          genericConverter.write(body, targetType, selectedMediaType, outputMessage);        }        else {          ((HttpMessageConverter) converter).write(body, selectedMediaType, outputMessage);        }      }      else {        if (logger.isDebugEnabled()) {          logger.debug(&quot;Nothing to write: null body&quot;);        }      }      return;    }  }...</code></pre><p>定义<code>ResponseBodyAdvice</code>的方式，如下：</p><pre><code class="java">@ControllerAdvicepublic class ResponseBodyAdviceExample implements ResponseBodyAdvice&lt;String&gt; {    @Override    public boolean supports(MethodParameter returnType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {        // todo        return false;    }    @Override    public String beforeBodyWrite(String body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {        // todo        return null;    }</code></pre><p>这样就可以在返回值处理之前实现自己的处理逻辑。</p><h3 id="二-总结"><a href="#二-总结" class="headerlink" title="二. 总结"></a>二. 总结</h3><ol><li><code>springMvc</code>会使用<code>returnValueHandlers</code>来处理<code>handler</code>的调用的返回值；</li><li><code>springMvc</code>支持的<code>controller</code>方法返回值有哪些；</li><li><code>ResponseBodyAdvice</code>的作用，以及如何自定义<code>ResponseBodyAdvice</code>;</li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析5.2——HandlerMethodArgumentResolver</title>
    <link href="/2020/02/27/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-2%E2%80%94%E2%80%94HandlerMethodArgumentResolver/"/>
    <url>/2020/02/27/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905-2%E2%80%94%E2%80%94HandlerMethodArgumentResolver/</url>
    
    <content type="html"><![CDATA[<blockquote><p>接着上一篇，我们来探究一下<code>RequestResponseBodyMethodProcessor</code>。</p></blockquote><h3 id="一-类实现图"><a href="#一-类实现图" class="headerlink" title="一. 类实现图"></a>一. 类实现图</h3><p><img src="/2020/02/27/SpringMvc源码分析5-2——HandlerMethodArgumentResolver/AbstractMessageConverterMethodArgumentResolver.png" srcset="/img/loading.gif" alt="AbstractMessageConverterMethodArgumentResolver"></p><p>回顾一下<code>HandlerMethodArgumentResolver</code>的两个方法：</p><pre><code>public interface HandlerMethodArgumentResolver {   boolean supportsParameter(MethodParameter parameter);   Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,         NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;}</code></pre><h3 id="二-源码分析"><a href="#二-源码分析" class="headerlink" title="二. 源码分析"></a>二. 源码分析</h3><p>我们首先从抽象类<code>AbstractMessageConverterMethodArgumentResolver</code>看起，</p><h4 id="1-AbstractMessageConverterMethodArgumentResolver"><a href="#1-AbstractMessageConverterMethodArgumentResolver" class="headerlink" title="1. AbstractMessageConverterMethodArgumentResolver"></a>1. AbstractMessageConverterMethodArgumentResolver</h4><blockquote><p>通过使用<code>HttpMessageConverter</code>从请求的主体读取内容来解析方法参数值的基类</p></blockquote><p>该抽象类里面包含了一些属性：</p><pre><code class="java">// 支持的http方法private static final Set&lt;HttpMethod&gt; SUPPORTED_METHODS =            EnumSet.of(HttpMethod.POST, HttpMethod.PUT, HttpMethod.PATCH);// 消息转换器(重要)protected final List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;// 支持的MediaTypeprotected final List&lt;MediaType&gt; allSupportedMediaTypes;// 这个的作用是在GenericHttpMessageConverter.read前后做一些自定义处理// 我们可以实现RequestBodyAdvice或者ResponseBodyAdvice并标注@ControllerAdvice，从而自定义一些处理private final RequestResponseBodyAdviceChain advice;</code></pre><p>该抽象类定义一些供子类使用的方法。如<code>readWithMessageConverters(..)</code>从<code>HttpInputMessage</code>中读取并创建期待的参数值，还有<code>validateIfApplicable(..)</code>参数值的校验等。</p><pre><code class="java">protected &lt;T&gt; Object readWithMessageConverters(HttpInputMessage inputMessage, MethodParameter parameter,      Type targetType) throws IOException, HttpMediaTypeNotSupportedException, HttpMessageNotReadableException {   MediaType contentType;   boolean noContentType = false;   try {      contentType = inputMessage.getHeaders().getContentType();   }   catch (InvalidMediaTypeException ex) {      throw new HttpMediaTypeNotSupportedException(ex.getMessage());   }   if (contentType == null) {      noContentType = true;      contentType = MediaType.APPLICATION_OCTET_STREAM;   }   Class&lt;?&gt; contextClass = parameter.getContainingClass();   Class&lt;T&gt; targetClass = (targetType instanceof Class ? (Class&lt;T&gt;) targetType : null);   if (targetClass == null) {      ResolvableType resolvableType = ResolvableType.forMethodParameter(parameter);      targetClass = (Class&lt;T&gt;) resolvableType.resolve();   }   HttpMethod httpMethod = (inputMessage instanceof HttpRequest ? ((HttpRequest) inputMessage).getMethod() : null);   Object body = NO_VALUE;   EmptyBodyCheckingHttpInputMessage message;   try {      message = new EmptyBodyCheckingHttpInputMessage(inputMessage);      for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {         Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();         GenericHttpMessageConverter&lt;?&gt; genericConverter =               (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null);         if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :               (targetClass != null &amp;&amp; converter.canRead(targetClass, contentType))) {            if (message.hasBody()) {               HttpInputMessage msgToUse =                     getAdvice().beforeBodyRead(message, parameter, targetType, converterType);               body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :                     ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));               body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);            }            else {               body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);            }            break;         }      }   }   catch (IOException ex) {      throw new HttpMessageNotReadableException(&quot;I/O error while reading input message&quot;, ex, inputMessage);   }   if (body == NO_VALUE) {      if (httpMethod == null || !SUPPORTED_METHODS.contains(httpMethod) ||            (noContentType &amp;&amp; !message.hasBody())) {         return null;      }      throw new HttpMediaTypeNotSupportedException(contentType, this.allSupportedMediaTypes);   }   MediaType selectedContentType = contentType;   Object theBody = body;   LogFormatUtils.traceDebug(logger, traceOn -&gt; {      String formatted = LogFormatUtils.formatValue(theBody, !traceOn);      return &quot;Read \&quot;&quot; + selectedContentType + &quot;\&quot; to [&quot; + formatted + &quot;]&quot;;   });   return body;}protected void validateIfApplicable(WebDataBinder binder, MethodParameter parameter) {        Annotation[] annotations = parameter.getParameterAnnotations();        for (Annotation ann : annotations) {            Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class);            if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(&quot;Valid&quot;)) {                Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann));                Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] {hints});                binder.validate(validationHints);                break;            }        }    }</code></pre><h4 id="2-RequestPartMethodArgumentResolver"><a href="#2-RequestPartMethodArgumentResolver" class="headerlink" title="2. RequestPartMethodArgumentResolver"></a>2. RequestPartMethodArgumentResolver</h4><blockquote><p>该参数解析器支持<code>@RequestPart</code>,处理文件的上传。可以与<code>@RequestParam</code>处理上传做一个对比。这两个注解处理文件上传用的不是一个参数解析器。</p></blockquote><h4 id="3-AbstractMessageConverterMethodProcessor"><a href="#3-AbstractMessageConverterMethodProcessor" class="headerlink" title="3. AbstractMessageConverterMethodProcessor"></a>3. AbstractMessageConverterMethodProcessor</h4><blockquote><p>拓展了<code>AbstractMessageConverterMethodArgumentResolver</code>使其能够使用<code>HttpMessageConverters</code>处理方法的返回。多实现了一个<code>HandlerMethodReturnValueHandler</code>接口。</p></blockquote><p>这个类里面主要封装了一些对<code>handler</code>返回值的写出，返回值的处理我们暂不说明。</p><h4 id="4-RequestResponseBodyMethodProcessor"><a href="#4-RequestResponseBodyMethodProcessor" class="headerlink" title="4. RequestResponseBodyMethodProcessor"></a>4. RequestResponseBodyMethodProcessor</h4><blockquote><p>支持<code>@RequestBody</code>参数的处理，参数的解析核心还是调用<code>RequestResponseBodyMethodProcessor#readWithMessageConverters(..)</code></p></blockquote><h4 id="5-HttpEntityMethodProcessor"><a href="#5-HttpEntityMethodProcessor" class="headerlink" title="5. HttpEntityMethodProcessor"></a>5. HttpEntityMethodProcessor</h4><blockquote><p>支持<code>HttpEntity</code>或者<code>RequestEntity</code>参数的处理，参数的解析核心还是调用<code>RequestResponseBodyMethodProcessor#readWithMessageConverters(..)</code></p></blockquote><p>整个下来，发现，核心还是在<code>RequestResponseBodyMethodProcessor#readWithMessageConverters(..)</code>。</p><p>那我们直接看一下该方法<code>readWithMessageConverters(..)</code>关键的解析<code>body</code>的一段:</p><pre><code class="java"> for (HttpMessageConverter&lt;?&gt; converter : this.messageConverters) {         Class&lt;HttpMessageConverter&lt;?&gt;&gt; converterType = (Class&lt;HttpMessageConverter&lt;?&gt;&gt;) converter.getClass();         GenericHttpMessageConverter&lt;?&gt; genericConverter =               (converter instanceof GenericHttpMessageConverter ? (GenericHttpMessageConverter&lt;?&gt;) converter : null);         if (genericConverter != null ? genericConverter.canRead(targetType, contextClass, contentType) :               (targetClass != null &amp;&amp; converter.canRead(targetClass, contentType))) {            if (message.hasBody()) {               // RequestBodyAdvice前置处理               HttpInputMessage msgToUse =                     getAdvice().beforeBodyRead(message, parameter, targetType, converterType);               // 消息转换               body = (genericConverter != null ? genericConverter.read(targetType, contextClass, msgToUse) :                     ((HttpMessageConverter&lt;T&gt;) converter).read(targetClass, msgToUse));              //  RequestBodyAdvice后置处理              body = getAdvice().afterBodyRead(body, msgToUse, parameter, targetType, converterType);            }            else {               body = getAdvice().handleEmptyBody(null, message, parameter, targetType, converterType);            }            break;         }      }   }</code></pre><p>这里面涉及到了<code>HttpMessageConverter</code>和<code>RequestResponseBodyAdviceChain</code>这两个主要类。找到匹配的<code>HttpMessageConverter</code>读取<code>HttpInputMessage</code>。在之前我们其实debug看到过<code>spring</code>容器里面这些实例的值。咱们再次debug查看一下吧，先写一个能被该参数解析器处理的接口(这不是必须的)：</p><pre><code class="java">@PostMapping(&quot;test&quot;)@ResponseBodypublic String test(@RequestBody User user) {  System.out.println(user);  return &quot;ok&quot;;}</code></pre><p>利用<code>curl</code>命令请求：</p><pre><code>curl -H &quot;Content-Type:application/json&quot; -X POST --data &#39;{&quot;username&quot;:&quot;jack&quot;}&#39; http://localhost:8080/test</code></pre><p>可以看到这两个关键对象的值。</p><p><img src="/2020/02/27/SpringMvc源码分析5-2——HandlerMethodArgumentResolver/Xnip2020-02-27_16-13-35.jpg" srcset="/img/loading.gif" alt="Xnip2020-02-27_16-13-35"></p><p>我们继续debug，可以发现处理我们<code>/test</code>请求的<code>HttpMessageConverter</code>为<code>MappingJackson2HttpMessageConverter</code>，是利用<code>jackson</code>来将我们的<code>json</code>串转为<code>User</code>对象的。</p><p>在这里这个<code>advice</code>类并没有起到作用，因为没有找到匹配的<code>RequestBodyAdvice</code>。截图里面的<code>JsonViewRequestBodyAdvice</code>需要参数上带有<code>@JsonView</code>注解才能处理。</p><blockquote><p><code>@JsonView</code>是<code>jackson</code>提供的一个注解，作用是可以按需过滤对象属性，可以参考<a href="/2019/05/05/Jackson Annotations(二)/" title="Jackson Annotations(二)">Jackson Annotations(二)</a>。其实我们可以参考<code>JsonViewRequestBodyAdvice</code>来实现一些功能，比如：某个参数乃至整个请求体的加解密，使我们避免重复的样板代码。</p></blockquote><p>如果我们想要在消息转换前后实现自己的<code>advice</code>逻辑，我们可以在<code>springboot</code>如下实现：</p><pre><code class="java">// 1. 标注注解 2. 继承RequestBodyAdviceAdapter或者RequestBodyAdvice@ControllerAdvicepublic class RequestBodyAdviceExample extends RequestBodyAdviceAdapter {    @Override    public boolean supports(MethodParameter methodParameter, Type targetType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; converterType) {        // todo        return false;    }   // override其他方法}</code></pre><p>此时，再次debug查看，可以看到我们自定义的<code>advice</code>已经注入。</p><p><img src="/2020/02/27/SpringMvc源码分析5-2——HandlerMethodArgumentResolver/Xnip2020-02-27_17-12-34.jpg" srcset="/img/loading.gif" alt="Xnip2020-02-27_17-12-34"></p><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><ol><li>主要讲解了一下<code>AbstractMessageConverterMethodArgumentResolver</code>类型的参数解析器,从请求体里面获取消息并转换；</li><li><code>AbstractMessageConverterMethodArgumentResolver</code>会利用<code>HttpMessageConverter</code>去转换<code>http</code>消息体里面的消息；</li><li><code>RequestBodyAdvice</code>的作用，以及怎么实现自己的<code>RequestBodyAdvice</code>逻辑；</li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析5.1——HandlerMethodArgumentResolver</title>
    <link href="/2020/02/26/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905.1%E2%80%94%E2%80%94HandlerMethodArgumentResolver/"/>
    <url>/2020/02/26/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%905.1%E2%80%94%E2%80%94HandlerMethodArgumentResolver/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 上一节，我们留下了几个问题。这里就先来分析一下遗留的第一个问题——<code>handler</code>参数的解析过程。</p></blockquote><h3 id="一-追踪源码"><a href="#一-追踪源码" class="headerlink" title="一. 追踪源码"></a>一. 追踪源码</h3><p>上一节，我们定位到了<code>ServletInvocableHandlerMethod#invokeAndHandle</code>:</p><pre><code class="java">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,      Object... providedArgs) throws Exception {   // 重点，从请求上下文中解析出参数值，然后调用方法   Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);   // 设置响应状态   setResponseStatus(webRequest);   if (returnValue == null) {      if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {         disableContentCachingIfNecessary(webRequest);         mavContainer.setRequestHandled(true);         return;      }   }   else if (StringUtils.hasText(getResponseStatusReason())) {      mavContainer.setRequestHandled(true);      return;   }   mavContainer.setRequestHandled(false);   Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);   try {      // 重点关注，调用匹配的HandlerMethodReturnValueHandler      this.returnValueHandlers.handleReturnValue(            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);   }   catch (Exception ex) {      if (logger.isTraceEnabled()) {         logger.trace(formatErrorForReturnValue(returnValue), ex);      }      throw ex;   }}</code></pre><p>接下来我们就看一下<code>invokeForRequest(webRequest, mavContainer, providedArgs)</code>：</p><pre><code class="java">public Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,            Object... providedArgs) throws Exception {      // 解析参数        Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);        if (logger.isTraceEnabled()) {            logger.trace(&quot;Arguments: &quot; + Arrays.toString(args));        }        return doInvoke(args);    }</code></pre><p>该方法主要就是解析参数，然后调用。</p><p>主要看下<code>Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs)</code>:</p><pre><code class="java">protected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,            Object... providedArgs) throws Exception {        MethodParameter[] parameters = getMethodParameters();        if (ObjectUtils.isEmpty(parameters)) {            return EMPTY_ARGS;        }        Object[] args = new Object[parameters.length];        for (int i = 0; i &lt; parameters.length; i++) {            MethodParameter parameter = parameters[i];      // 设置参数名称解析器，主要用于获取变量参数名称            parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);      // 从提供的providedArgs获取参数值            args[i] = findProvidedArgument(parameter, providedArgs);            if (args[i] != null) {                continue;            }            if (!this.resolvers.supportsParameter(parameter)) {                throw new IllegalStateException(formatArgumentError(parameter, &quot;No suitable resolver&quot;));            }            try {        // 利用resolvers解析参数，重点关注                args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);            }            catch (Exception ex) {                // Leave stack trace for later, exception may actually be resolved and handled...                if (logger.isDebugEnabled()) {                    String exMsg = ex.getMessage();                    if (exMsg != null &amp;&amp; !exMsg.contains(parameter.getExecutable().toGenericString())) {                        logger.debug(formatArgumentError(parameter, exMsg));                    }                }                throw ex;            }        }        return args;    }</code></pre><p>参考上面代码上的注释。主要我们关注<code>this.resolvers.resolveArgument(..)</code>.而<code>resolvers</code>是从<code>RequestMappingHandlerAdapter</code>设置过来的。</p><p><img src="/2020/02/26/SpringMvc源码分析5.1——HandlerMethodArgumentResolver/resolvers.jpg" srcset="/img/loading.gif" alt="resolvers"></p><p>然后从这些<code>argumentResolvers</code>找到匹配的<code>HandlerMethodArgumentResolver</code>,然后执行它的<code>resolveArgument(..)</code>获得参数值。：</p><pre><code class="java">public Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,            NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {        HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);        if (resolver == null) {            throw new IllegalArgumentException(                    &quot;Unsupported parameter type [&quot; + parameter.getParameterType().getName() + &quot;].&quot; +                            &quot; supportsParameter should be called first.&quot;);        }        return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);    }</code></pre><p>到这我们可以看到参数的解析会依赖<code>HandlerMethodArgumentResolver</code>。所以接下来我们就主要看一下<code>HandlerMethodArgumentResolver</code>。</p><h3 id="二-HandlerMethodArgumentResolver"><a href="#二-HandlerMethodArgumentResolver" class="headerlink" title="二. HandlerMethodArgumentResolver"></a>二. HandlerMethodArgumentResolver</h3><blockquote><p>该接口是一个从请求上下文解析方法参数的策略接口</p></blockquote><h4 id="1-接口规范"><a href="#1-接口规范" class="headerlink" title="1. 接口规范"></a>1. 接口规范</h4><pre><code class="java">public interface HandlerMethodArgumentResolver {    /**     * Whether the given {@linkplain MethodParameter method parameter} is     * supported by this resolver.     * @param parameter the method parameter to check     * @return {@code true} if this resolver supports the supplied parameter;     * {@code false} otherwise     */  // 是否支持给某个方法参数的解析    boolean supportsParameter(MethodParameter parameter);    /**     * Resolves a method parameter into an argument value from a given request.     * A {@link ModelAndViewContainer} provides access to the model for the     * request. A {@link WebDataBinderFactory} provides a way to create     * a {@link WebDataBinder} instance when needed for data binding and     * type conversion purposes.     * @param parameter the method parameter to resolve. This parameter must     * have previously been passed to {@link #supportsParameter} which must     * have returned {@code true}.     * @param mavContainer the ModelAndViewContainer for the current request     * @param webRequest the current request     * @param binderFactory a factory for creating {@link WebDataBinder} instances     * @return the resolved argument value, or {@code null} if not resolvable     * @throws Exception in case of errors with the preparation of argument values     */    @Nullable  // 从给定的请求解析参数值    Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,            NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;}</code></pre><h4 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2. 接口实现"></a>2. 接口实现</h4><p><img src="/2020/02/26/SpringMvc源码分析5.1——HandlerMethodArgumentResolver/HandlerMethodArgumentResolver.png" srcset="/img/loading.gif" alt="HandlerMethodArgumentResolver"></p><p>可以看到的实现的类非常多。我们测试的接口：</p><pre><code class="java">@RestControllerpublic class IndexController {    @GetMapping(&quot;/hello&quot;)    public String hello(String name) {        return &quot;hello: &quot; + name;    }}</code></pre><p>匹配到的则是<code>RequestParamMethodArgumentResolver</code>.</p><p>那我们来看一下<code>RequestParamMethodArgumentResolver#supportsParameter</code>:</p><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {   if (parameter.hasParameterAnnotation(RequestParam.class)) {      if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {         RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);         return (requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name()));      }      else {         return true;      }   }   else {      if (parameter.hasParameterAnnotation(RequestPart.class)) {         return false;      }      parameter = parameter.nestedIfOptional();      if (MultipartResolutionDelegate.isMultipartArgument(parameter)) {         return true;      }      else if (this.useDefaultResolution) {         return BeanUtils.isSimpleProperty(parameter.getNestedParameterType());      }      else {         return false;      }   }}</code></pre><p>可以看到<code>RequestParamMethodArgumentResolver</code>支持:</p><ol><li><code>@RequestParam</code>标注的参数的处理，</li><li>没有标注<code>@RequestParam</code>的简单类型，如<code>int, long,String</code>等;</li><li><code>结合MultipartResolver</code>，也支持<code>@RequestParam MultipartFile file</code></li><li>结合<code>Servlet 3.0 multipart requests</code>，也支持<code>javax.servlet.http.Part</code>  </li></ol><p><code>HandlerMethodArgumentResolver</code>的实现类非常多。我们一定使用过<code>@RequestParam</code>,<code>PathVariable</code>,<code>@Value</code>,<code>@RequestHeader</code>,<code>@CookieValue</code>,<code>SessionAttribute</code>,<code>RequestAttribute</code>等等。而这些的解析起都是<code>AbstractNamedValueMethodArgumentResolver</code>的子类。我们先来看一下类的实现继承关系图，然后再分析源码：</p><p><img src="/2020/02/26/SpringMvc源码分析5.1——HandlerMethodArgumentResolver/AbstractNamedValueMethodArgumentResolver.png" srcset="/img/loading.gif" alt="AbstractNamedValueMethodArgumentResolver"></p><h4 id="3-AbstractNamedValueMethodArgumentResolver"><a href="#3-AbstractNamedValueMethodArgumentResolver" class="headerlink" title="3. AbstractNamedValueMethodArgumentResolver"></a>3. AbstractNamedValueMethodArgumentResolver</h4><blockquote><p>这是一个从命名值中解析方法参数的基类。比如从请求参数，请求头路径变量中获取。每种方式都有一个名称，是否必须的标识以及一个默认值。</p><p>子类需要做的事情：</p><ul><li>获取方法参数的命名值信息</li><li>将名称解析为参数值</li><li>在需要参数值时处理缺少的参数值</li><li>（可选）处理解析值</li></ul><p>需要注意的一点就是默认String值支持<code>${...}</code>和<code>EL</code>表达式，但是这歌功能的支持需要<code>ConfigurableBeanFactory</code>的支持。</p></blockquote><p>看一下代码：</p><pre><code class="java">public abstract class AbstractNamedValueMethodArgumentResolver implements HandlerMethodArgumentResolver {   @Nullable   private final ConfigurableBeanFactory configurableBeanFactory;   @Nullable   private final BeanExpressionContext expressionContext;   private final Map&lt;MethodParameter, NamedValueInfo&gt; namedValueInfoCache = new ConcurrentHashMap&lt;&gt;(256);   @Override   @Nullable   public final Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,         NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {         // 这一步获取参数名称相关信息      NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);      //对于Optional的处理      MethodParameter nestedParameter = parameter.nestedIfOptional();      // 解析${...}，EL表达式，获取解析后的nama值      Object resolvedName = resolveStringValue(namedValueInfo.name);      if (resolvedName == null) {         throw new IllegalArgumentException(               &quot;Specified name must not resolve to null: [&quot; + namedValueInfo.name + &quot;]&quot;);      }     // 获取参数值，模版方法，具体的实现交给子类      Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest);      if (arg == null) {         if (namedValueInfo.defaultValue != null) {           // 设置了默认值            arg = resolveStringValue(namedValueInfo.defaultValue);         }         else if (namedValueInfo.required &amp;&amp; !nestedParameter.isOptional()) {            // 处理没有值的情况，默认抛出异常，子类可以Override            handleMissingValue(namedValueInfo.name, nestedParameter, webRequest);         }         arg = handleNullValue(namedValueInfo.name, arg, nestedParameter.getNestedParameterType());      }      else if (&quot;&quot;.equals(arg) &amp;&amp; namedValueInfo.defaultValue != null) {         arg = resolveStringValue(namedValueInfo.defaultValue);      }      // 数据绑定      if (binderFactory != null) {         WebDataBinder binder = binderFactory.createBinder(webRequest, null, namedValueInfo.name);         try {            // 是否需要进行参数类型的转换            arg = binder.convertIfNecessary(arg, parameter.getParameterType(), parameter);         }         catch (ConversionNotSupportedException ex) {            throw new MethodArgumentConversionNotSupportedException(arg, ex.getRequiredType(),                  namedValueInfo.name, parameter, ex.getCause());         }         catch (TypeMismatchException ex) {            throw new MethodArgumentTypeMismatchException(arg, ex.getRequiredType(),                  namedValueInfo.name, parameter, ex.getCause());         }      }      // protected的方法，交给子类去复写（并不是必须的）      handleResolvedValue(arg, namedValueInfo.name, parameter, mavContainer, webRequest);      return arg;   }   /**    * Obtain the named value for the given method parameter.    */   private NamedValueInfo getNamedValueInfo(MethodParameter parameter) {      NamedValueInfo namedValueInfo = this.namedValueInfoCache.get(parameter);      if (namedValueInfo == null) {         // 抽象方法，交给子类实现         namedValueInfo = createNamedValueInfo(parameter);         namedValueInfo = updateNamedValueInfo(parameter, namedValueInfo);         this.namedValueInfoCache.put(parameter, namedValueInfo);      }      return namedValueInfo;   }   /**    * Represents the information about a named value, including name, whether it&#39;s required and a default value.    */   protected static class NamedValueInfo {      private final String name;      private final boolean required;      @Nullable      private final String defaultValue;      public NamedValueInfo(String name, boolean required, @Nullable String defaultValue) {         this.name = name;         this.required = required;         this.defaultValue = defaultValue;      }   }}</code></pre><p>利用模版设计模式，该抽象类中定义了解析参数的主要逻辑，子类只需要实现对应的抽象模版方法即可。<br>这里面规定了如下流程:</p><ol><li>基于<code>MethodParameter</code>构建<code>NameValueInfo</code>，主要是要解析方法参数上标注的注解</li><li>解析<code>${}</code>占位符以及<code>SpEL</code>得到解析后的<code>name</code></li><li><code>Object arg = resolveName(resolvedName.toString(), nestedParameter, webRequest)</code>，解析参数值(具体由子类去实现)</li><li>处理没有解析出参数值的一些情况</li><li>通过<code>WebDataBinder</code>将<code>arg</code>转换成<code>Methodparameter.getParameterType()</code>类型。</li></ol><p>所以子类的话，需要做的就是：</p><ol><li><p>实现<code>public boolean supportsParameter(MethodParameter parameter)</code></p></li><li><p>实现<code>protected abstract NamedValueInfo createNamedValueInfo(MethodParameter parameter);</code></p></li><li><p>实现<code>protected abstract Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception</code></p></li><li><p>其他非必须的，比如<code>handleMissingValue(..)</code>,<code>handleResolvedValue(..)</code></p></li></ol><p>那么我们来看一下一些具体的子类实现：</p><h5 id="1-RequestParamMethodArgumentResolver"><a href="#1-RequestParamMethodArgumentResolver" class="headerlink" title="1. RequestParamMethodArgumentResolver"></a>1. RequestParamMethodArgumentResolver</h5><pre><code class="java">public boolean supportsParameter(MethodParameter parameter) {        if (parameter.hasParameterAnnotation(RequestParam.class)) {            if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {                RequestParam requestParam = parameter.getParameterAnnotation(RequestParam.class);                return (requestParam != null &amp;&amp; StringUtils.hasText(requestParam.name()));            }            else {                return true;            }        }        else {            if (parameter.hasParameterAnnotation(RequestPart.class)) {                return false;            }            parameter = parameter.nestedIfOptional();            if (MultipartResolutionDelegate.isMultipartArgument(parameter)) {                return true;            }            else if (this.useDefaultResolution) {                return BeanUtils.isSimpleProperty(parameter.getNestedParameterType());            }            else {                return false;            }        }    }</code></pre><blockquote><p>支持的方法参数的判断，比如@RequestParam，Optional,简单类型的解析。</p></blockquote><pre><code class="java">protected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {        RequestParam ann = parameter.getParameterAnnotation(RequestParam.class);        return (ann != null ? new RequestParamNamedValueInfo(ann) : new RequestParamNamedValueInfo());    }</code></pre><blockquote><p>其实就是获取<code>@RequestParam</code>注解里面的信息</p></blockquote><pre><code class="java">protected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) throws Exception {        HttpServletRequest servletRequest = request.getNativeRequest(HttpServletRequest.class);        if (servletRequest != null) {            Object mpArg = MultipartResolutionDelegate.resolveMultipartArgument(name, parameter, servletRequest);            if (mpArg != MultipartResolutionDelegate.UNRESOLVABLE) {                return mpArg;            }        }        Object arg = null;        MultipartRequest multipartRequest = request.getNativeRequest(MultipartRequest.class);        if (multipartRequest != null) {            List&lt;MultipartFile&gt; files = multipartRequest.getFiles(name);            if (!files.isEmpty()) {                arg = (files.size() == 1 ? files.get(0) : files);            }        }        if (arg == null) {            String[] paramValues = request.getParameterValues(name);            if (paramValues != null) {                arg = (paramValues.length == 1 ? paramValues[0] : paramValues);            }        }        return arg;    }</code></pre><blockquote><p>利用request.getParameterValues(name)获取值，也支持Multipart请求(如：文件上传)的解析。</p></blockquote><p>这里举一个<code>${..}</code>和<code>el</code>表达式的示例吧：</p><p>在配置文件<code>application.yml</code>里面添加配置：</p><pre><code class="yaml">app:  arg0: name</code></pre><p>然后添加一个接口：</p><pre><code class="java">@GetMapping(&quot;test&quot;)    @ResponseBody    public String test(@RequestParam(&quot;${app.arg0}&quot;) String a,                @RequestParam(value = &quot;age&quot;, required = false, defaultValue = &quot;#{12 * 2}&quot;) String b) {        log.info(&quot;a: {}, b: {}&quot;, a, b);        return &quot;ok&quot;;    }</code></pre><p>我们就是要演示通过占位符获取<code>name</code>的值，和得到默认的<code>age</code>，请求：</p><pre><code>curl http://localhost:8080/namedValue/test10?name=jack</code></pre><p>打印结果：</p><pre><code>2020-02-26 21:51:32.396  INFO 84285 --- [nio-8080-exec-1] c.j.s.c.ArgumentsResolveController       : a: jack, b: 24</code></pre><h5 id="2-PathVariableMethodArgumentResolver"><a href="#2-PathVariableMethodArgumentResolver" class="headerlink" title="2. PathVariableMethodArgumentResolver"></a>2. PathVariableMethodArgumentResolver</h5><pre><code class="java">@Override    public boolean supportsParameter(MethodParameter parameter) {        if (!parameter.hasParameterAnnotation(PathVariable.class)) {            return false;        }        if (Map.class.isAssignableFrom(parameter.nestedIfOptional().getNestedParameterType())) {            PathVariable pathVariable = parameter.getParameterAnnotation(PathVariable.class);            return (pathVariable != null &amp;&amp; StringUtils.hasText(pathVariable.value()));        }        return true;    }</code></pre><blockquote><p>支持@PathVariable的解析</p></blockquote><h5 id="3-ExpressionValueMethodArgumentResolver"><a href="#3-ExpressionValueMethodArgumentResolver" class="headerlink" title="3. ExpressionValueMethodArgumentResolver"></a>3. ExpressionValueMethodArgumentResolver</h5><blockquote><p>这个比较简单，支持<code>@Value</code>的解析，<code>resolveName(..)</code>直接返回<code>null</code>，主要是利用默认值来解析<code>@Value</code>里<code>value</code>值。</p></blockquote><pre><code class="java">// 支持@Value参数public boolean supportsParameter(MethodParameter parameter) {  return parameter.hasParameterAnnotation(Value.class);}// 直接返回nullprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest webRequest) throws Exception {  // No name to resolve  return null;}@Overrideprotected NamedValueInfo createNamedValueInfo(MethodParameter parameter) {  Value ann = parameter.getParameterAnnotation(Value.class);  Assert.state(ann != null, &quot;No Value annotation&quot;);  return new ExpressionValueNamedValueInfo(ann);}private static final class ExpressionValueNamedValueInfo extends NamedValueInfo {    // 将注解的value值赋值给defaultValue，利用defaultValue的解析得到参数值  private ExpressionValueNamedValueInfo(Value annotation) {    super(&quot;@Value&quot;, false, annotation.value());  }}</code></pre><p>剩下一些就不去一一记录了，原理差不多，也比简单。</p><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>总结一下到这主要分析得到了些什么:</p><ol><li>代码定位到了参数解析这一步，并debug看到了默认的<code>resolvers</code>，可以看到其中默认的顺序;</li><li>了解<code>HandlerMethodArgumentResolver</code>的作用以及它的实现结构图；</li><li>分析了<code>AbstractNamedValueMethodArgumentResolver</code>的作用，了解了它一些子类的的实现。</li></ol><p>在controller方法里到底支持那些参数类型呢？直接拿<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-arguments" target="_blank" rel="noopener">官方文档</a>看一下：</p><table><thead><tr><th style="text-align:left">Controller method argument</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td style="text-align:left"><code>WebRequest</code>, <code>NativeWebRequest</code></td><td style="text-align:left">Generic access to request parameters and request and session attributes, without direct use of the Servlet API.</td></tr><tr><td style="text-align:left"><code>javax.servlet.ServletRequest</code>, <code>javax.servlet.ServletResponse</code></td><td style="text-align:left">Choose any specific request or response type — for example, <code>ServletRequest</code>, <code>HttpServletRequest</code>, or Spring’s <code>MultipartRequest</code>, <code>MultipartHttpServletRequest</code>.</td></tr><tr><td style="text-align:left"><code>javax.servlet.http.HttpSession</code></td><td style="text-align:left">Enforces the presence of a session. As a consequence, such an argument is never <code>null</code>. Note that session access is not thread-safe. Consider setting the <code>RequestMappingHandlerAdapter</code> instance’s <code>synchronizeOnSession</code> flag to <code>true</code> if multiple requests are allowed to concurrently access a session.</td></tr><tr><td style="text-align:left"><code>javax.servlet.http.PushBuilder</code></td><td style="text-align:left">Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected <code>PushBuilder</code> instance can be null if the client does not support that HTTP/2 feature.</td></tr><tr><td style="text-align:left"><code>java.security.Principal</code></td><td style="text-align:left">Currently authenticated user — possibly a specific <code>Principal</code> implementation class if known.</td></tr><tr><td style="text-align:left"><code>HttpMethod</code></td><td style="text-align:left">The HTTP method of the request.</td></tr><tr><td style="text-align:left"><code>java.util.Locale</code></td><td style="text-align:left">The current request locale, determined by the most specific <code>LocaleResolver</code> available (in effect, the configured <code>LocaleResolver</code> or <code>LocaleContextResolver</code>).</td></tr><tr><td style="text-align:left"><code>java.util.TimeZone</code> + <code>java.time.ZoneId</code></td><td style="text-align:left">The time zone associated with the current request, as determined by a <code>LocaleContextResolver</code>.</td></tr><tr><td style="text-align:left"><code>java.io.InputStream</code>, <code>java.io.Reader</code></td><td style="text-align:left">For access to the raw request body as exposed by the Servlet API.</td></tr><tr><td style="text-align:left"><code>java.io.OutputStream</code>, <code>java.io.Writer</code></td><td style="text-align:left">For access to the raw response body as exposed by the Servlet API.</td></tr><tr><td style="text-align:left"><code>@PathVariable</code></td><td style="text-align:left">For access to URI template variables. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestmapping-uri-templates" target="_blank" rel="noopener">URI patterns</a>.</td></tr><tr><td style="text-align:left"><code>@MatrixVariable</code></td><td style="text-align:left">For access to name-value pairs in URI path segments. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-matrix-variables" target="_blank" rel="noopener">Matrix Variables</a>.</td></tr><tr><td style="text-align:left"><code>@RequestParam</code></td><td style="text-align:left">For access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestparam" target="_blank" rel="noopener"><code>@RequestParam</code></a> as well as <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-multipart-forms" target="_blank" rel="noopener">Multipart</a>.Note that use of <code>@RequestParam</code> is optional for simple parameter values. See “Any other argument”, at the end of this table.</td></tr><tr><td style="text-align:left"><code>@RequestHeader</code></td><td style="text-align:left">For access to request headers. Header values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestheader" target="_blank" rel="noopener"><code>@RequestHeader</code></a>.</td></tr><tr><td style="text-align:left"><code>@CookieValue</code></td><td style="text-align:left">For access to cookies. Cookies values are converted to the declared method argument type. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-cookievalue" target="_blank" rel="noopener"><code>@CookieValue</code></a>.</td></tr><tr><td style="text-align:left"><code>@RequestBody</code></td><td style="text-align:left">For access to the HTTP request body. Body content is converted to the declared method argument type by using <code>HttpMessageConverter</code> implementations. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestbody" target="_blank" rel="noopener"><code>@RequestBody</code></a>.</td></tr><tr><td style="text-align:left"><code>HttpEntity</code></td><td style="text-align:left">For access to request headers and body. The body is converted with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-httpentity" target="_blank" rel="noopener">HttpEntity</a>.</td></tr><tr><td style="text-align:left"><code>@RequestPart</code></td><td style="text-align:left">For access to a part in a <code>multipart/form-data</code> request, converting the part’s body with an <code>HttpMessageConverter</code>. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-multipart-forms" target="_blank" rel="noopener">Multipart</a>.</td></tr><tr><td style="text-align:left"><code>java.util.Map</code>, <code>org.springframework.ui.Model</code>, <code>org.springframework.ui.ModelMap</code></td><td style="text-align:left">For access to the model that is used in HTML controllers and exposed to templates as part of view rendering.</td></tr><tr><td style="text-align:left"><code>RedirectAttributes</code></td><td style="text-align:left">Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-redirecting-passing-data" target="_blank" rel="noopener">Redirect Attributes</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-flash-attributes" target="_blank" rel="noopener">Flash Attributes</a>.</td></tr><tr><td style="text-align:left"><code>@ModelAttribute</code></td><td style="text-align:left">For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-modelattrib-method-args" target="_blank" rel="noopener"><code>@ModelAttribute</code></a> as well as <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-modelattrib-methods" target="_blank" rel="noopener">Model</a> and <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-initbinder" target="_blank" rel="noopener"><code>DataBinder</code></a>.Note that use of <code>@ModelAttribute</code> is optional (for example, to set its attributes). See “Any other argument” at the end of this table.</td></tr><tr><td style="text-align:left"><code>Errors</code>, <code>BindingResult</code></td><td style="text-align:left">For access to errors from validation and data binding for a command object (that is, a <code>@ModelAttribute</code> argument) or errors from the validation of a <code>@RequestBody</code> or <code>@RequestPart</code> arguments. You must declare an <code>Errors</code>, or <code>BindingResult</code> argument immediately after the validated method argument.</td></tr><tr><td style="text-align:left"><code>SessionStatus</code> + class-level <code>@SessionAttributes</code></td><td style="text-align:left">For marking form processing complete, which triggers cleanup of session attributes declared through a class-level <code>@SessionAttributes</code> annotation. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-sessionattributes" target="_blank" rel="noopener"><code>@SessionAttributes</code></a> for more details.</td></tr><tr><td style="text-align:left"><code>UriComponentsBuilder</code></td><td style="text-align:left">For preparing a URL relative to the current request’s host, port, scheme, context path, and the literal part of the servlet mapping. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-uri-building" target="_blank" rel="noopener">URI Links</a>.</td></tr><tr><td style="text-align:left"><code>@SessionAttribute</code></td><td style="text-align:left">For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level <code>@SessionAttributes</code> declaration. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-sessionattribute" target="_blank" rel="noopener"><code>@SessionAttribute</code></a> for more details.</td></tr><tr><td style="text-align:left"><code>@RequestAttribute</code></td><td style="text-align:left">For access to request attributes. See <a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-ann-requestattrib" target="_blank" rel="noopener"><code>@RequestAttribute</code></a> for more details.</td></tr><tr><td style="text-align:left">Any other argument</td><td style="text-align:left">If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by <a href="https://docs.spring.io/spring-framework/docs/5.2.3.RELEASE/javadoc-api/org/springframework/beans/BeanUtils.html#isSimpleProperty-java.lang.Class-" target="_blank" rel="noopener">BeanUtils#isSimpleProperty</a>, it is a resolved as a <code>@RequestParam</code>. Otherwise, it is resolved as a <code>@ModelAttribute</code>.</td></tr></tbody></table><p>对于每种支持的类型，我们都可以找到具体的<code>HandlerMethodArgumentResolver</code>，大家可以debug一探究竟。在工作中我使用的比较多的还有<code>@RequestBody</code>,那么也很有必要去分析一下对应的源码。这就涉及到<code>RequestResponseBodyMethodProcessor</code>了，我们下一篇接着分析。</p>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析4.2——HandlerAdapter</title>
    <link href="/2020/02/25/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-2%E2%80%94%E2%80%94HandlerAdapter/"/>
    <url>/2020/02/25/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-2%E2%80%94%E2%80%94HandlerAdapter/</url>
    
    <content type="html"><![CDATA[<h3 id="一-准备"><a href="#一-准备" class="headerlink" title="一. 准备"></a>一. 准备</h3><p>接着上一篇，我们暴露的接口:</p><pre><code class="java">@RestControllerpublic class IndexController {    @GetMapping(&quot;/hello&quot;)    public String hello(String name) {        return &quot;hello: &quot; + name;    }}</code></pre><p>bebug到<code>DispatcherServlet#doDispatch</code>：</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        // 1. 关注点一                mappedHandler = getHandler(processedRequest);                // 2. 关注点二                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());              // 3. todo待分析，关注点三                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());              // 4. todo待分析，关注点四                applyDefaultViewName(processedRequest, mv);              // 5. todo待分析，关注点五               processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);    }</code></pre><h3 id="二-分析"><a href="#二-分析" class="headerlink" title="二. 分析"></a>二. 分析</h3><h4 id="1-关注几个属性值"><a href="#1-关注几个属性值" class="headerlink" title="1. 关注几个属性值"></a>1. 关注几个属性值</h4><p>我们先看一下<code>DispatcherServlet</code>内部几个属性此时的值：</p><pre><code class="java">/** List of HandlerMappings used by this servlet. */    @Nullable    private List&lt;HandlerMapping&gt; handlerMappings;    /** List of HandlerAdapters used by this servlet. */    @Nullable    private List&lt;HandlerAdapter&gt; handlerAdapters;    /** List of HandlerExceptionResolvers used by this servlet. */    @Nullable    private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;    /** RequestToViewNameTranslator used by this servlet. */    @Nullable    private RequestToViewNameTranslator viewNameTranslator;/** List of ViewResolvers used by this servlet. */    @Nullable    private List&lt;ViewResolver&gt; viewResolvers;</code></pre><ul><li><p>handlerMappings   <img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/handlerMappings.jpg" srcset="/img/loading.gif" alt="handlerMappings"></p></li><li><p>handlerAdapters</p><p><img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/handlerAdapters.jpg" srcset="/img/loading.gif" alt></p></li><li><p>handlerExceptionResolvers  <img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/handlerExceptionResolvers.jpg" srcset="/img/loading.gif" alt="handlerExceptionResolvers"></p></li><li><p>viewNameTranslator<img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/viewNameTranslator.jpg" srcset="/img/loading.gif" alt="viewNameTranslator"></p></li><li><p>viewResolvers<img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/viewResolvers.jpg" srcset="/img/loading.gif" alt="viewResolvers"></p></li></ul><h4 id="2-关注点三源码"><a href="#2-关注点三源码" class="headerlink" title="2. 关注点三源码"></a>2. 关注点三源码</h4><blockquote><p>mv = ha.handle(processedRequest, response, mappedHandler.getHandler())</p></blockquote><p>执行具体的<code>handler</code>并返回<code>ModelAndView</code>对象；从可以知道，这里的<code>ha</code>为<code>RequestMappingHandlerAdapter</code>。顺序执行链我们最终定位到<code>RequestMappingHandlerAdapter#handleInternal</code>，源码如下：</p><pre><code class="java">protected ModelAndView handleInternal(HttpServletRequest request,            HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {        ModelAndView mav;      // 校验请求的method和是否需要session        checkRequest(request);        // Execute invokeHandlerMethod in synchronized block if required.      // 这里有一个配置，因为session不是线程安全的，这里可以配置使其同步执行        if (this.synchronizeOnSession) {            HttpSession session = request.getSession(false);            if (session != null) {                Object mutex = WebUtils.getSessionMutex(session);                synchronized (mutex) {                    mav = invokeHandlerMethod(request, response, handlerMethod);                }            }            else {                // No HttpSession available -&gt; no mutex necessary                mav = invokeHandlerMethod(request, response, handlerMethod);            }        }        else {            // No synchronization on session demanded at all...      // todo待分析            mav = invokeHandlerMethod(request, response, handlerMethod);        }      // 删减        ....        return mav;    }</code></pre><p>该方法里面首先进行了一个校验<code>checkRequest</code>主要是校验请求的<code>method</code>和是否需要<code>session</code>。然后做了一个是否需要在<code>session</code>上的同步判断。该<code>synchronizeOnSession</code>默认值为<code>false</code>的，默认<code>Session</code>是有线程安全问题的，如果这个值设置为<code>true</code>而且有<code>session</code>的话，就会同步执行<code>invokeHandlerMethod()</code>，从而避免<code>session</code>的线程安全问题。接着，再调用<code>mav = invokeHandlerMethod(request, response, handlerMethod);</code>执行<code>handler</code>：</p><pre><code class="java">protected ModelAndView invokeHandlerMethod(HttpServletRequest request,            HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {        ServletWebRequest webRequest = new ServletWebRequest(request, response);        try {      // 包含了对@InitBinder的处理            WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);      // 包含了对@ModelAttribute的处理            ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);      // 设置参数解析器，参数名解析等            ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);            if (this.argumentResolvers != null) {                invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);            }            if (this.returnValueHandlers != null) {                invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);            }            invocableMethod.setDataBinderFactory(binderFactory);            invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);            ModelAndViewContainer mavContainer = new ModelAndViewContainer();            mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));            modelFactory.initModel(webRequest, mavContainer, invocableMethod);            mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);      // 删除异步请求的处理代码            ...      // 调用方法并通过配置的HandlerMethodReturnValueHandlers之一来处理返回值。重点关注            invocableMethod.invokeAndHandle(webRequest, mavContainer);            if (asyncManager.isConcurrentHandlingStarted()) {                return null;            }      // ModelAndView            return getModelAndView(mavContainer, modelFactory, webRequest);        }        finally {            webRequest.requestCompleted();        }    }</code></pre><p>到这，我们先来看一下<code>RequestMappingHandlerAdapter</code>里面的几个属性此时的值：</p><pre><code class="java">  // 自定义参数解析器，会后于内置的参数解析器    @Nullable    private List&lt;HandlerMethodArgumentResolver&gt; customArgumentResolvers;    // 参数解析器    @Nullable    private HandlerMethodArgumentResolverComposite argumentResolvers;  // 在{@code @InitBinder}方法中配置支持的参数类型    @Nullable    private HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;    // 自定义返回值处理器，会后于内置的返回值处理器    @Nullable    private List&lt;HandlerMethodReturnValueHandler&gt; customReturnValueHandlers;  // 返回值处理器    @Nullable    private HandlerMethodReturnValueHandlerComposite returnValueHandlers;  // 消息转换器    private List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters;  // RequestBodyAdvice或者ResponseBodyAdvice  private List&lt;Object&gt; requestResponseBodyAdvice = new ArrayList&lt;&gt;();</code></pre><ul><li>customArgumentResolvers</li></ul><p>​    此时为空，没有自定义</p><ul><li>argumentResolvers</li></ul><p><img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/argumentResolvers.jpg" srcset="/img/loading.gif" alt="argumentResolvers"></p><ul><li>initBinderArgumentResolvers</li></ul><p><img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/initBinderArgumentResolvers.jpg" srcset="/img/loading.gif" alt="initBinderArgumentResolvers"></p><ul><li>customReturnValueHandlers</li></ul><p>​    为空，没有自定义</p><ul><li>returnValueHandlers</li></ul><p><img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/returnValueHandlers.jpg" srcset="/img/loading.gif" alt="returnValueHandlers"></p><ul><li>messageConverters</li></ul><p><img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/messageConverters.jpg" srcset="/img/loading.gif" alt="messageConverters"></p><ul><li>requestResponseBodyAdvice</li></ul><p><img src="/2020/02/25/SpringMvc源码分析4-2——HandlerAdapter/requestResponseBodyAdvice.jpg" srcset="/img/loading.gif" alt="requestResponseBodyAdvice"></p><p>从源码上看，我们需要重点关注一下<code>invocableMethod.invokeAndHandle(webRequest, mavContainer);</code>,如下：</p><pre><code class="java">public void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,      Object... providedArgs) throws Exception {   // 重点，从请求上下文中解析出参数值，然后调用方法   Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);   // 设置响应状态   setResponseStatus(webRequest);   if (returnValue == null) {      if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {         disableContentCachingIfNecessary(webRequest);         mavContainer.setRequestHandled(true);         return;      }   }   else if (StringUtils.hasText(getResponseStatusReason())) {      mavContainer.setRequestHandled(true);      return;   }   mavContainer.setRequestHandled(false);   Assert.state(this.returnValueHandlers != null, &quot;No return value handlers&quot;);   try {      // 重点关注，调用匹配的HandlerMethodReturnValueHandler      this.returnValueHandlers.handleReturnValue(            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);   }   catch (Exception ex) {      if (logger.isTraceEnabled()) {         logger.trace(formatErrorForReturnValue(returnValue), ex);      }      throw ex;   }}</code></pre><p>这个方法，里面就包括了<code>handler</code>方法参数的解析，方法的处理，返回值的处理等，这需要我们重点分析。分析这一块我们能看到<code>@RequestParam</code>，<code>@RequestBody</code>，<code>@ResponseBody</code>等的处理过程。内容有点多，放到下一节单独分析。</p><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>到此，我们大概分析了一下<code>ha.handle(processedRequest, response, mappedHandler.getHandler())</code>的执行逻辑。这其中有很多复杂的逻辑，由于我们的测试请求很简单，项目也没有做什么其他的配置，所以很多流程代码执行不到。但是没关系，我们从简单的做起，也能了解得到<code>SpringMvc</code>处理请求一个大概的流程。OK，回顾一下，这一节主要了解到了：</p><ol><li><code>synchronizeOnSession</code>的作用；</li><li>参数值的解析，需要用到<code>argumentResolvers</code>，<strong>todo分析</strong>；</li><li>返回值的主力需要用到<code>returnValueHandlers</code>，<strong>todo分析</strong>；</li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析4.1——HandlerAdapter</title>
    <link href="/2020/02/25/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-1%E2%80%94%E2%80%94HandlerAdapter/"/>
    <url>/2020/02/25/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%904-1%E2%80%94%E2%80%94HandlerAdapter/</url>
    
    <content type="html"><![CDATA[<h3 id="一-准备"><a href="#一-准备" class="headerlink" title="一. 准备"></a>一. 准备</h3><p>接着上一篇，我们暴露的接口:</p><pre><code class="java">@RestControllerpublic class IndexController {    @GetMapping(&quot;/hello&quot;)    public String hello(String name) {        return &quot;hello: &quot; + name;    }}</code></pre><p>bebug到<code>DispatcherServlet#doDispatch</code>：</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        // 1. 关注点一                mappedHandler = getHandler(processedRequest);                // 2. todo待分析，关注点二                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());              // 3. todo待分析，关注点三                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());              // 4. todo待分析，关注点四                applyDefaultViewName(processedRequest, mv);              // 5. todo待分析，关注点五               processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);    }</code></pre><h3 id="二-分析"><a href="#二-分析" class="headerlink" title="二. 分析"></a>二. 分析</h3><h4 id="1-关注几个属性值"><a href="#1-关注几个属性值" class="headerlink" title="1. 关注几个属性值"></a>1. 关注几个属性值</h4><p>我们先看一下<code>DispatcherServlet</code>内部几个属性此时的值：</p><pre><code class="java">/** List of HandlerMappings used by this servlet. */    @Nullable    private List&lt;HandlerMapping&gt; handlerMappings;    /** List of HandlerAdapters used by this servlet. */    @Nullable    private List&lt;HandlerAdapter&gt; handlerAdapters;    /** List of HandlerExceptionResolvers used by this servlet. */    @Nullable    private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;    /** RequestToViewNameTranslator used by this servlet. */    @Nullable    private RequestToViewNameTranslator viewNameTranslator;/** List of ViewResolvers used by this servlet. */    @Nullable    private List&lt;ViewResolver&gt; viewResolvers;</code></pre><ul><li><p>handlerMappings   <img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/handlerMappings.jpg" srcset="/img/loading.gif" alt="handlerMappings"></p></li><li><p>handlerAdapters</p><p><img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/handlerAdapters.jpg" srcset="/img/loading.gif" alt></p></li><li><p>handlerExceptionResolvers  <img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/handlerExceptionResolvers.jpg" srcset="/img/loading.gif" alt="handlerExceptionResolvers"></p></li><li><p>viewNameTranslator<img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/viewNameTranslator.jpg" srcset="/img/loading.gif" alt="viewNameTranslator"></p></li><li><p>viewResolvers<img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/viewResolvers.jpg" srcset="/img/loading.gif" alt="viewResolvers"></p></li></ul><h4 id="2-关注点二源码"><a href="#2-关注点二源码" class="headerlink" title="2. 关注点二源码"></a>2. 关注点二源码</h4><blockquote><p>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</p></blockquote><p>这里主要是根据获取到的<code>handler</code>找到匹配的<code>HandlerAdapter</code>,源码如下：</p><pre><code class="java">protected HandlerAdapter getHandlerAdapter(Object handler) throws ServletException {        if (this.handlerAdapters != null) {            for (HandlerAdapter adapter : this.handlerAdapters) {                if (adapter.supports(handler)) {                    return adapter;                }            }        }        throw new ServletException(&quot;No adapter for handler [&quot; + handler +                &quot;]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handler&quot;);    }</code></pre><p>首先我们再次看一下<code>HandlerAdapter结构图</code>：</p><p><img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/HandlerAdapter.png" srcset="/img/loading.gif" alt="HandlerAdapter"></p><pre><code class="java">public interface HandlerAdapter {    // 判断是否支持给定的handler    boolean supports(Object handler);  // 用给定的handler处理请求    @Nullable    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>比如，我们测试的项目，注入的<code>HandlerAdapter</code>为：</p><p><img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/handlerAdapters.jpg" srcset="/img/loading.gif" alt="handlerAdapters"></p><table><thead><tr><th>HandlerAdapter类型</th><th>支持的handler</th></tr></thead><tbody><tr><td>HttpRequestHandlerAdapter</td><td>HttpRequestHandler</td></tr><tr><td>SimpleControllerHandlerAdapter</td><td>org.springframework.web.servlet.mvc.Controller实例</td></tr><tr><td>RequestMappingHandlerAdapter</td><td>handler instanceof HandlerMethod</td></tr></tbody></table><p>从<a href="/2020/02/25/SpringMvc源码分析3——HandlerMapping/" title="SpringMvc源码分析3——HandlerMapping">SpringMvc源码分析3——HandlerMapping</a>可以知道，<code>handler</code>类型为<code>HandlerMethod</code>,所以，这一步<code>getHandlerAdapter</code>得到的<code>HandlerAdapter</code>为<code>RequestMappingHandlerAdapter</code>。</p><p><em>关注点二就分析到这，那么大家有没有疑问，<code>DispatcherServlet</code>里面的这些属性，如<code>handlerAdapters</code>是什么时候初始化的呢？</em></p><h3 id="三-handlerAdapters等的初始化"><a href="#三-handlerAdapters等的初始化" class="headerlink" title="三. handlerAdapters等的初始化"></a>三. handlerAdapters等的初始化</h3><blockquote><p>既然<code>DispatcherServlet</code>是<code>Servlet</code>，那么就肯定会执行它的<code>init()</code>方法；</p></blockquote><p>观察<code>DispatcherServlet</code>，发现里面有一个<code>DispatcherServlet#initStrategies</code>方法,如下：</p><pre><code class="java">protected void initStrategies(ApplicationContext context) {        initMultipartResolver(context);        initLocaleResolver(context);        initThemeResolver(context);        initHandlerMappings(context);        initHandlerAdapters(context);        initHandlerExceptionResolvers(context);        initRequestToViewNameTranslator(context);        initViewResolvers(context);        initFlashMapManager(context);    }</code></pre><p>这里面包含了一系列属性的初始化。那么直接在这个方法内debug，然后启动<code>springboot</code>应用，可以看到调用栈：</p><p><img src="/2020/02/25/SpringMvc源码分析4-1——HandlerAdapter/initStrategies.jpg" srcset="/img/loading.gif" alt="initStrategies"></p><p>我们可以看到<code>Servlet</code>的<code>init()</code>调用过程。</p><p>然后来看下，<code>initHandlerAdapters(context)</code>源码:</p><pre><code>private void initHandlerAdapters(ApplicationContext context) {   this.handlerAdapters = null;   //  detectAllHandlerAdapters 默认为true   if (this.detectAllHandlerAdapters) {      // Find all HandlerAdapters in the ApplicationContext, including ancestor contexts.      Map&lt;String, HandlerAdapter&gt; matchingBeans =            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerAdapter.class, true, false);      if (!matchingBeans.isEmpty()) {         this.handlerAdapters = new ArrayList&lt;&gt;(matchingBeans.values());         // We keep HandlerAdapters in sorted order.         AnnotationAwareOrderComparator.sort(this.handlerAdapters);      }   }   else {      try {         HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);         this.handlerAdapters = Collections.singletonList(ha);      }      catch (NoSuchBeanDefinitionException ex) {         // Ignore, we&#39;ll add a default HandlerAdapter later.      }   }   // Ensure we have at least some HandlerAdapters, by registering   // default HandlerAdapters if no other adapters are found.   if (this.handlerAdapters == null) {      this.handlerAdapters = getDefaultStrategies(context, HandlerAdapter.class);      if (logger.isTraceEnabled()) {         logger.trace(&quot;No HandlerAdapters declared for servlet &#39;&quot; + getServletName() +               &quot;&#39;: using default strategies from DispatcherServlet.properties&quot;);      }   }}</code></pre><p>初始化<code>handlerAdapters</code>分了这几种情况：</p><ol><li><p><code>detectAllHandlerAdapter</code>为<code>true</code>(默认就为<code>true</code>)，会从应用上下文中找到所有的<code>HandlerAdapters</code>,然后做一个排序。</p></li><li><p><code>detectAllHandlerAdapter</code>为<code>false</code>，就会找到名称为<code>handlerAdapter</code>的<code>handlerAdapter</code>。</p></li><li><p>最后，如果<code>handlerAdapters</code>仍然为空，则会走默认的策略。这默认的实现可以在<code>DispatcherServlet.properties</code>查看到，如下：</p><pre><code># Default implementation classes for DispatcherServlet&#39;s strategy interfaces.# Used as fallback when no matching beans are found in the DispatcherServlet context.# Not meant to be customized by application developers.org.springframework.web.servlet.LocaleResolver=org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolverorg.springframework.web.servlet.ThemeResolver=org.springframework.web.servlet.theme.FixedThemeResolverorg.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\    org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\    org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapterorg.springframework.web.servlet.HandlerExceptionResolver=org.springframework.web.servlet.mvc.method.annotation.ExceptionHandlerExceptionResolver,\    org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\    org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolverorg.springframework.web.servlet.RequestToViewNameTranslator=org.springframework.web.servlet.view.DefaultRequestToViewNameTranslatororg.springframework.web.servlet.ViewResolver=org.springframework.web.servlet.view.InternalResourceViewResolverorg.springframework.web.servlet.FlashMapManager=org.springframework.web.servlet.support.SessionFlashMapManager</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析3——HandlerMapping</title>
    <link href="/2020/02/25/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903%E2%80%94%E2%80%94HandlerMapping/"/>
    <url>/2020/02/25/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%903%E2%80%94%E2%80%94HandlerMapping/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringMvc源码分析3——HandlerMapping"><a href="#SpringMvc源码分析3——HandlerMapping" class="headerlink" title="SpringMvc源码分析3——HandlerMapping"></a>SpringMvc源码分析3——HandlerMapping</h2><h3 id="一-准备"><a href="#一-准备" class="headerlink" title="一. 准备"></a>一. 准备</h3><p>首先再次贴一下<code>HandlerMapping</code>结构图：</p><p><img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/HandlerMapping.png" srcset="/img/loading.gif" alt="HandlerMapping"></p><p>接着上一篇，我们暴露的接口:</p><pre><code class="java">@RestControllerpublic class IndexController {    @GetMapping(&quot;/hello&quot;)    public String hello(String name) {        return &quot;hello: &quot; + name;    }}</code></pre><p>bebug到<code>DispatcherServlet#doDispatch</code>：</p><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    // 1. todo待分析，关注点一    mappedHandler = getHandler(processedRequest);    // 2. todo待分析，关注点二    HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());    // 3. todo待分析，关注点三    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());    // 4. todo待分析，关注点四    applyDefaultViewName(processedRequest, mv);    // 5. todo待分析，关注点五    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);}</code></pre><h3 id="二-分析"><a href="#二-分析" class="headerlink" title="二. 分析"></a>二. 分析</h3><h4 id="1-关注几个属性值"><a href="#1-关注几个属性值" class="headerlink" title="1. 关注几个属性值"></a>1. 关注几个属性值</h4><p>我们先看一下<code>DispatcherServlet</code>内部几个属性此时的值：</p><pre><code class="java">/** List of HandlerMappings used by this servlet. */    @Nullable    private List&lt;HandlerMapping&gt; handlerMappings;    /** List of HandlerAdapters used by this servlet. */    @Nullable    private List&lt;HandlerAdapter&gt; handlerAdapters;    /** List of HandlerExceptionResolvers used by this servlet. */    @Nullable    private List&lt;HandlerExceptionResolver&gt; handlerExceptionResolvers;    /** RequestToViewNameTranslator used by this servlet. */    @Nullable    private RequestToViewNameTranslator viewNameTranslator;/** List of ViewResolvers used by this servlet. */    @Nullable    private List&lt;ViewResolver&gt; viewResolvers;</code></pre><ul><li><p>handlerMappings   <img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/handlerMappings.jpg" srcset="/img/loading.gif" alt="handlerMappings"></p></li><li><p>handlerAdapters</p><p><img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/handlerAdapters.jpg" srcset="/img/loading.gif" alt></p></li><li><p>handlerExceptionResolvers  <img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/handlerExceptionResolvers.jpg" srcset="/img/loading.gif" alt="handlerExceptionResolvers"></p></li><li><p>viewNameTranslator<img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/viewNameTranslator.jpg" srcset="/img/loading.gif" alt="viewNameTranslator"></p></li><li><p>viewResolvers<img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/viewResolvers.jpg" srcset="/img/loading.gif" alt="viewResolvers"></p></li></ul><h4 id="2-关注点一源码"><a href="#2-关注点一源码" class="headerlink" title="2. 关注点一源码"></a>2. 关注点一源码</h4><blockquote><p>mappedHandler = getHandler(processedRequest);</p></blockquote><p>这里主要是根据请求找到匹配的<code>HandlerMapping</code>，然后得到相应的<code>handler</code>和拦截器，封装成<code>HandlerExecutionChain</code>返回。</p><p>源码：</p><pre><code class="java">protected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {        if (this.handlerMappings != null) {            for (HandlerMapping mapping : this.handlerMappings) {        // todo分析                HandlerExecutionChain handler = mapping.getHandler(request);                if (handler != null) {                    return handler;                }            }        }        return null;    }</code></pre><p>找到的匹配到<code>HandlerMapping</code>为<code>RequestMappingHandlerMapping</code>.接着执行:</p><pre><code class="java">public final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {  // 得到handler  Object handler = getHandlerInternal(request);        if (handler == null) {            handler = getDefaultHandler();        }        if (handler == null) {            return null;        }      // 获取到请求的拦截器，封装成HandlerExecutionChain返回        HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);        return executionChain;    }</code></pre><p><code>RequestMappingHandlerMapping</code>里面维护着<code>mappingRegistry</code>,它的值为：</p><blockquote><p>其实<code>mappingRegistry</code>属性在<code>AbstractHandlerMethodMapping</code>里面。</p></blockquote><p><img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/mappingRegistry.jpg" srcset="/img/loading.gif" alt="mappingRegistry">然后根据请求找出里面匹配到的<code>RequestMappingInfo</code>，从而得到<code>HandlerMethod</code>对象。</p><p>最后得到的<code>handler</code>为：</p><p><img src="/2020/02/25/SpringMvc源码分析3——HandlerMapping/handler.jpg" srcset="/img/loading.gif" alt="handler"></p><p>之后，获取到请求的拦截器，再封装成HandlerExecutionChain返回。对应代码为：</p><pre><code class="java">protected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {        HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?                (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));        String lookupPath = this.urlPathHelper.getLookupPathForRequest(request);        for (HandlerInterceptor interceptor : this.adaptedInterceptors) {            if (interceptor instanceof MappedInterceptor) {                MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;                if (mappedInterceptor.matches(lookupPath, this.pathMatcher)) {                    chain.addInterceptor(mappedInterceptor.getInterceptor());                }            }            else {                chain.addInterceptor(interceptor);            }        }        return chain;    }</code></pre><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p><code>HandlerMapping</code>的作用其实就是请求和具体<code>Handler</code>处理器(这里的<code>Handler</code>一般为<code>Controller</code>里的一个方法<code>method</code>，或者<code>org.springframework.web.servlet.mvc.Controller</code>等)之间的一个映射关系。</p><p>如<code>SimpleUrlHandlerMapping</code>则是会根据内部维护的<code>urlMap</code>(以路径作为键，并以处理程序bean或bean名称作为值的Map)查找具体的<code>handler</code>。</p><p>而<code>RequestMappingHandlerMapping</code>则会处理请求和注解(<code>@Controller</code>，<code>@RequestMapping</code>)方法对应的映射关系。</p>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析2——DispatcherServlet</title>
    <link href="/2020/02/24/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%E2%80%94%E2%80%94DispatcherServlet/"/>
    <url>/2020/02/24/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%902%E2%80%94%E2%80%94DispatcherServlet/</url>
    
    <content type="html"><![CDATA[<blockquote><p>从SpringMvc的中心处理器<code>DispatcherServlet</code>开始说起。源码主要是基于<code>jdk1.8</code>,<code>springboot 2.1.6.RELEASE</code>,添加一个<code>spring-boot-starter-web</code>依赖。</p></blockquote><h3 id="一-DispatcherServlet结构图"><a href="#一-DispatcherServlet结构图" class="headerlink" title="一. DispatcherServlet结构图"></a>一. DispatcherServlet结构图</h3><p><img src="/2020/02/24/SpringMvc源码分析2——DispatcherServlet/DispatcherServlet.png" srcset="/img/loading.gif" alt="DispatcherServlet"></p><h3 id="二-测试代码"><a href="#二-测试代码" class="headerlink" title="二. 测试代码"></a>二. 测试代码</h3><blockquote><p>首先我们先暴露一个接口</p></blockquote><pre><code>@RestControllerpublic class IndexController {    @GetMapping(&quot;/hello&quot;)    public String hello(String name) {        return &quot;hello: &quot; + name;    }}</code></pre><p>调用<code>http://localhost:8080/hello</code>:</p><h4 id="1-调用链"><a href="#1-调用链" class="headerlink" title="1. 调用链"></a>1. 调用链</h4><p>Debug一下: 查看一下调用链，如下：</p><p><img src="/2020/02/24/SpringMvc源码分析2——DispatcherServlet/Xnip2020-02-24_15-02-06.jpg" srcset="/img/loading.gif" alt="Xnip2020-02-24_15-02-06"></p><pre><code class="java">  1. HttpServlet  public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException  2. FrameworkServlet  protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException  3. HttpServlet  protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException  4. FrameworkServlet  protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException  5. DispatcherServlet  protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception  6. DispatcherServlet  protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception</code></pre><p>我们查看一下具体的代码，</p><h4 id="2-FrameworkServlet-processRequest"><a href="#2-FrameworkServlet-processRequest" class="headerlink" title="2. FrameworkServlet#processRequest"></a>2. <code>FrameworkServlet#processRequest</code></h4><blockquote><p>代码进行了一些删减</p></blockquote><pre><code class="java">/** * 处理此请求，不考虑结果而发布事件,实际事件处理由抽象执行 */protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {  LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();        LocaleContext localeContext = buildLocaleContext(request);        RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();        ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());      // 设置了LocaleContextHolder和RequestContextHolder，使用ThreadLocal保存，所以在之后可以直接通过LocaleContextHolder，RequestContextHolder获取相关信息        initContextHolders(request, localeContext, requestAttributes);        try {      // todo下面分析            doService(request, response);        } catch (ServletException | IOException ex) {            failureCause = ex;            throw ex;        }        catch (Throwable ex) {            failureCause = ex;            throw new NestedServletException(&quot;Request processing failed&quot;, ex);        }        finally {      // 重置LocaleContextHolder和RequestContextHolder            resetContextHolders(request, previousLocaleContext, previousAttributes);            if (requestAttributes != null) {                requestAttributes.requestCompleted();            }            logResult(request, response, failureCause, asyncManager);      // 发布相关事件            publishRequestHandledEvent(request, response, startTime, failureCause);        }    }</code></pre><p>前一部分是将当前请求的Locale对象和请求的属性，通过<code>LocaleContextHolder</code>和<code>RequestContextHolder</code>设置到<code>ThreadLocal</code>对象中，也就是分别将这两个对象和请求线程做了绑定。之后我们就可以从里面获取这些绑定的值使用。调用<code>doService()</code>处理结束后，再通过<code>LocaleContextHolder</code>和<code>RequestContextHolder</code>恢复相应的绑定。接着发布了一个<code>ServletRequestHandledEvent</code>事件。具体我们再看<code>doService()</code>方法。</p><h4 id="3-DispatcherServlet-doService"><a href="#3-DispatcherServlet-doService" class="headerlink" title="3. DispatcherServlet#doService"></a>3. <code>DispatcherServlet#doService</code></h4><pre><code class="java">protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception {        logRequest(request);        // Keep a snapshot of the request attributes in case of an include,        // to be able to restore the original attributes after the include.        Map&lt;String, Object&gt; attributesSnapshot = null;        if (WebUtils.isIncludeRequest(request)) {            attributesSnapshot = new HashMap&lt;&gt;();            Enumeration&lt;?&gt; attrNames = request.getAttributeNames();            while (attrNames.hasMoreElements()) {                String attrName = (String) attrNames.nextElement();                if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) {                    attributesSnapshot.put(attrName, request.getAttribute(attrName));                }            }        }        // Make framework objects available to handlers and view objects.      // 给request设置一些属性        request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());        request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver);        request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver);        request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());        if (this.flashMapManager != null) {            FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response);            if (inputFlashMap != null) {                request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));            }            request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap());            request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager);        }        try {            doDispatch(request, response);        }        finally {            if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) {                // Restore the original attribute snapshot, in case of an include.                if (attributesSnapshot != null) {                    restoreAttributesAfterInclude(request, attributesSnapshot);                }            }        }    }</code></pre><p>这里面有几个<code>requet.setAttribute()</code>方法的调用，将之前在初始化流程中实例化的对象设置到<code>request</code>的属性中，供下一步处理使用，这里有web上下文，本地化解析器等。然后继续调用<code>doDispatch()</code>处理请求。</p><h4 id="4-DispatcherServlet-doDispatch"><a href="#4-DispatcherServlet-doDispatch" class="headerlink" title="4. DispatcherServlet#doDispatch"></a>4. <code>DispatcherServlet#doDispatch</code></h4><pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {        HttpServletRequest processedRequest = request;        HandlerExecutionChain mappedHandler = null;        boolean multipartRequestParsed = false;        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);        try {            ModelAndView mv = null;            Exception dispatchException = null;            try {                processedRequest = checkMultipart(request);                multipartRequestParsed = (processedRequest != request);                // Determine handler for the current request.        // 根据当前请求获取HandlerMapping，并得到HandlerExecutionChain                mappedHandler = getHandler(processedRequest);                if (mappedHandler == null) {                    noHandlerFound(processedRequest, response);                    return;                }                // Determine handler adapter for the current request.        // 获取匹配的HandlerAdapter                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());                // Process last-modified header, if supported by the handler.                String method = request.getMethod();                boolean isGet = &quot;GET&quot;.equals(method);                if (isGet || &quot;HEAD&quot;.equals(method)) {                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                    if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) {                        return;                    }                }        // 执行拦截器的 preHandle()方法                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    return;                }                // Actually invoke the handler.        // 调用handler，得到ModelAndView                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                if (asyncManager.isConcurrentHandlingStarted()) {                    return;                }                applyDefaultViewName(processedRequest, mv);        // 执行拦截器的 postHandle()方法                mappedHandler.applyPostHandle(processedRequest, response, mv);            }            catch (Exception ex) {                dispatchException = ex;            }            catch (Throwable err) {                // As of 4.3, we&#39;re processing Errors thrown from handler methods as well,                // making them available for @ExceptionHandler methods and other scenarios.                dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);            }      // 处理ModelAndView,最后再执行拦截器的 afterCompletion()方法            processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);        }        catch (Exception ex) {      // 异常，执行拦截器的 afterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler, ex);        }        catch (Throwable err) {      // 异常，执行拦截器的 afterCompletion()方法            triggerAfterCompletion(processedRequest, response, mappedHandler,                    new NestedServletException(&quot;Handler processing failed&quot;, err));        }        finally {            if (asyncManager.isConcurrentHandlingStarted()) {                // Instead of postHandle and afterCompletion                if (mappedHandler != null) {                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);                }            }            else {                // Clean up any resources used by a multipart request.                if (multipartRequestParsed) {                    cleanupMultipart(processedRequest);                }            }        }    }</code></pre><p>到此终于找了处理流程的主线，我们看到了一系列<a href="/2020/02/24/SpringMvc源码分析1/" title="SpringMvc源码分析1">SpringMvc源码分析1</a> 中介绍的对象，以及处理流程。</p><p>这里会从<code>DispatcherServlet</code>内维护的<code>handlerMappings</code>中找到匹配的<code>HandlerMapping</code>方法，并执行其<code>getHandler()</code>方法，得到<code>HandlerExecutionChain</code>,看一下具体的内部结构：</p><p><img src="/2020/02/24/SpringMvc源码分析2——DispatcherServlet/HandlerExecutionChain.png" srcset="/img/loading.gif" alt="HandlerExecutionChain.png"></p><p>可以看到维护了<code>handler</code>和拦截器列表。</p><p>接着<code>HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</code>得到<code>HandlerAdapter</code>，然后执行拦截器的<code>postHandle()</code>方法。之后调用<code>HandlerAdapter</code>的<code>handle()</code>,处理<code>controller</code>里面的逻辑，得到<code>ModelAndView</code>,接着执行拦截器的<code>postHandle()</code>方法。然后就会根据<code>viewResolvers</code>得到具体的视图<code>View</code>，最后就是渲染视图，返回给客户端。</p><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>到此，我们可以了解<code>DispatcherServlet</code>大概的处理流程。其中</p><p><code>mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code>还有很多的处理逻辑，包括<code>HandlerMethodArgumentResolver</code>,<code>HandlerMethodReturnValueHandler</code>,<code>HttpMessageConverter</code>等的处理，我们后面继续分析。</p>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc源码分析1</title>
    <link href="/2020/02/24/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"/>
    <url>/2020/02/24/SpringMvc%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<h2 id="SpringMvc源码分析1"><a href="#SpringMvc源码分析1" class="headerlink" title="SpringMvc源码分析1"></a>SpringMvc源码分析1</h2><blockquote><p>由于疫情影响，在家正好抽时间整理一下SpringMvc相关源码内容。望疫情早点结束，迎暖阳，赏春光！</p></blockquote><h3 id="一-架构流程"><a href="#一-架构流程" class="headerlink" title="一. 架构流程"></a>一. 架构流程</h3><blockquote><p>首先，画了一个大概的springmvc处理请求的流程图。</p></blockquote><p><img src="/2020/02/24/SpringMvc源码分析1/mvc1.jpg" srcset="/img/loading.gif" alt="mvc"></p><p><strong>1:</strong> 客户端发起请求，请求进入<code>DispatcherServlet</code>统一处理;</p><p><strong>2-3:</strong> <code>DispatcherServlet</code>从内部维护的<code>handlerMappings</code>列表中查找适合的<code>HandlerMapping</code>,然后调用其<code>getHandler(request)</code>方法，返回<code>HandlerExecutionChain</code>。<code>HandlerExecutionChain</code>包含了具体的处理器<code>handler</code>和拦截器列表<code>interceptorList</code>;</p><p><strong>4:</strong> 根据得到的<code>handler</code>从内部维护的<code>handlerAdapters</code>中获取匹配的<code>HandlerAdapter</code>；</p><p><strong>5-7:</strong> 执行<code>HandlerAdapter</code>的<code>handle(HttpServletRequest request, HttpServletResponse response, Object handler)</code>方法,返回<code>ModelAndView</code>;</p><p><strong>8-9:</strong> 使用从内部维护的<code>viewResolvers</code>得到具体的视图<code>View</code>对象;</p><p><strong>10-11:</strong> 渲染该视图<code>View</code>，返回给客户端；</p><h3 id="二-接口抽象"><a href="#二-接口抽象" class="headerlink" title="二. 接口抽象"></a>二. 接口抽象</h3><blockquote><p>我们来关注几个关键的接口</p></blockquote><ol><li><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a><code>HandlerMapping</code></h4></li></ol><blockquote><p>该接口主要就是根据请求，来获取处理器执行链——包括具体的处理器和拦截器。</p></blockquote><pre><code class="java">public interface HandlerMapping {     HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception; }</code></pre><p>查看一下接口实现图(已删除一些)：</p><p><img src="/2020/02/24/SpringMvc源码分析1/HandlerMapping.png" srcset="/img/loading.gif" alt="HandlerMapping"></p><blockquote><p>之后我们会具体关注<code>RequestMappingHandlerMapping</code>。</p></blockquote><ol start="2"><li><h4 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a><code>HandlerAdapter</code></h4></li></ol><blockquote><p>用来处理具体的handler逻辑，如调用controller里面的代码。</p></blockquote><pre><code class="java">public interface HandlerAdapter {    boolean supports(Object handler);    ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception;    long getLastModified(HttpServletRequest request, Object handler);}</code></pre><p>查看一下接口实现图：</p><p><img src="/2020/02/24/SpringMvc源码分析1/HandlerAdapter.png" srcset="/img/loading.gif" alt="HandlerAdapter"></p><blockquote><p>之后我们会具体关注<code>RequestMappingHandlerAdapter</code></p></blockquote><p>这一块内容包括很多，比如参数的绑定，handler方法的执行，返回值的绑定等等。我们先大概了解一下SpringMvc处理请求的流程，接下来我们再查看具体的源码。OK，这一篇先记录到这里。</p>]]></content>
    
    
    <categories>
      
      <category>SpringMvc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>监控Feign调用metrics</title>
    <link href="/2020/02/22/%E7%9B%91%E6%8E%A7Feign%E8%B0%83%E7%94%A8metrics/"/>
    <url>/2020/02/22/%E7%9B%91%E6%8E%A7Feign%E8%B0%83%E7%94%A8metrics/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我们公司的微服务去年已经开始使用metrics来收集应用运行指标，结合prometheus和grafana来统一收集和可视化。服务间的调用我们是使用Feign来进行调用的，但是发现springboot应用没法收集Feign调用得metrics信息，特此，记录一下怎么收集Feign调用的metrics信息。</p></blockquote><p>首先我们来看一下springboot2.X默认使用的metrics指标工具<a href="http://micrometer.io/" target="_blank" rel="noopener">micrometer</a>,查看它的官方文档，我们发现它对okhttp做了支持，如下：<br><img src="/2020/02/22/监控Feign调用metrics/Xnip2020-02-22_11-18-23.jpg" srcset="/img/loading.gif" alt></p><ul><li><a href="http://micrometer.io/docs/ref/okhttpclient" target="_blank" rel="noopener">OkHttpClient Metrics</a></li></ul><p>既然如此，那么我们可以调整Feign的默认底层调用实现，使其使用okhttp来调用，从而解决Feign的metrics指标问题。</p><p>在此，我们需要注意的是<code>OkHttpClient Metrics</code>使用的okhttp的<code>eventListener</code>功能，这个功能在早期的okhttp没有提供。我查看了一下<a href="https://square.github.io/okhttp/changelog_3x/" target="_blank" rel="noopener">okhttp文档</a>,发现如下：</p><pre><code>Version 3.11.0...New: The EventListener API previewed in OkHttp 3.9 has graduated to a stable API. Use this interface to track metrics and monitor HTTP requests’ size and duration.</code></pre><p>表明，在3.11.0版本，该功能已经稳定。所以我们需要的版本&gt;=3.11.0<br>下面，开始演示。</p><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1. pom.xml"></a>1. pom.xml</h4><pre><code class="xml">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;        &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;        &lt;version&gt;10.7.4&lt;/version&gt;        &lt;exclusions&gt;            &lt;exclusion&gt;                &lt;artifactId&gt;okhttp&lt;/artifactId&gt;                &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;            &lt;/exclusion&gt;        &lt;/exclusions&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt;        &lt;artifactId&gt;okhttp&lt;/artifactId&gt;        &lt;version&gt;3.14.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.micrometer&lt;/groupId&gt;        &lt;artifactId&gt;micrometer-registry-prometheus&lt;/artifactId&gt;        &lt;version&gt;1.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h4 id="2-Feign底层使用okhttp"><a href="#2-Feign底层使用okhttp" class="headerlink" title="2. Feign底层使用okhttp"></a>2. Feign底层使用okhttp</h4><ul><li>配置文件<pre><code class="yaml">feign:httpclient:  enabled: falseokhttp:  enabled: true</code></pre></li><li>springboot配置<blockquote><p>我们可以直接将FeignAutoConfiguration里面的okhttp配置拿出来</p></blockquote></li></ul><p>配置如下：</p><pre><code class="java">@Configurationpublic class FeignConfig {    @Configuration    @ConditionalOnClass(OkHttpClient.class)    @ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)    @ConditionalOnProperty(&quot;feign.okhttp.enabled&quot;)    protected static class OkHttpFeignConfiguration {        private okhttp3.OkHttpClient okHttpClient;        @Bean        @ConditionalOnMissingBean(ConnectionPool.class)        public ConnectionPool httpClientConnectionPool(                FeignHttpClientProperties httpClientProperties,                OkHttpClientConnectionPoolFactory connectionPoolFactory) {            int maxTotalConnections = httpClientProperties.getMaxConnections();            long timeToLive = httpClientProperties.getTimeToLive();            TimeUnit ttlUnit = httpClientProperties.getTimeToLiveUnit();            return connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit);        }        @Bean        public okhttp3.OkHttpClient client(OkHttpClientFactory httpClientFactory,                                           ConnectionPool connectionPool,                                           FeignHttpClientProperties httpClientProperties,                                           OkHttpMetricsEventListener okHttpMetricsEventListener) {            this.okHttpClient = httpClientFactory.createBuilder(httpClientProperties.isDisableSslValidation())                    .eventListener(okHttpMetricsEventListener) // 配置metrics监听器                    .connectTimeout(httpClientProperties.getConnectionTimeout(), TimeUnit.MILLISECONDS)                    .followRedirects(httpClientProperties.isFollowRedirects())                    .connectionPool(connectionPool)                    .build();            return this.okHttpClient;        }        @PreDestroy        public void destroy() {            if (this.okHttpClient != null) {                this.okHttpClient.dispatcher().executorService().shutdown();                this.okHttpClient.connectionPool().evictAll();            }        }        @Bean        public OkHttpMetricsEventListener okHttpMetricsEventListener(MeterRegistry meterRegistry) {            return  OkHttpMetricsEventListener.builder(meterRegistry, &quot;ok&quot;)                    .uriMapper(request -&gt; request.url().encodedPath()) // 默认也支持URI_PATTERN header支持uri tag                    .tags(Collections.emptyList()) // 这里可以指定自定义的tag                    .build();        }        @Bean        @ConditionalOnMissingBean(Client.class)        public Client feignClient(okhttp3.OkHttpClient client) {            return new OkHttpClient(client);        }    }}</code></pre><p>主要是增加了</p><pre><code class="java">....eventListener(okHttpMetricsEventListener) // 配置metrics监听器...@Beanpublic OkHttpMetricsEventListener okHttpMetricsEventListener(MeterRegistry meterRegistry) {      return  OkHttpMetricsEventListener.builder(meterRegistry, &quot;ok&quot;)              .uriMapper(request -&gt; request.url().encodedPath())              .tags(Collections.emptyList())              .build();  } </code></pre><h4 id="3-Feign请求代码"><a href="#3-Feign请求代码" class="headerlink" title="3. Feign请求代码"></a>3. Feign请求代码</h4><pre><code class="java">@FeignClient(name = &quot;test&quot;, url = &quot;http://localhost:8080&quot;)public interface TestClient {    @GetMapping(&quot;/api/test&quot;)    BaseResp&lt;String&gt; test();}@RestControllerpublic class FeignTestController {    @Autowired    private TestClient testClient;    @GetMapping(&quot;/test&quot;)    public String test() {        BaseResp&lt;String&gt; test = testClient.test();        System.out.println(test);        return &quot;ok&quot;;    }}</code></pre><p>然后通过web暴露出这个接口给外部调用。</p><h4 id="4-观察metrics信息"><a href="#4-观察metrics信息" class="headerlink" title="4. 观察metrics信息"></a>4. 观察metrics信息</h4><blockquote><p><a href="http://localhost:8080/actuator/prometheus" target="_blank" rel="noopener">http://localhost:8080/actuator/prometheus</a></p></blockquote><p>如下，是一段相关的信息</p><pre><code># HELP ok_seconds Timer of OkHttp operation# TYPE ok_seconds summaryok_seconds_count{host=&quot;localhost&quot;,method=&quot;GET&quot;,status=&quot;200&quot;,uri=&quot;/api/test&quot;,} 8.0ok_seconds_sum{host=&quot;localhost&quot;,method=&quot;GET&quot;,status=&quot;200&quot;,uri=&quot;/api/test&quot;,} 0.109059855# HELP ok_seconds_max Timer of OkHttp operation# TYPE ok_seconds_max gaugeok_seconds_max{host=&quot;localhost&quot;,method=&quot;GET&quot;,status=&quot;200&quot;,uri=&quot;/api/test&quot;,} 0.004678218</code></pre><p>到此，我们就可以获取到相关的Feign调用信息，然后就可以进行相关的监控和可视化展示。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Feign</tag>
      
      <tag>metrics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot: no suitable HttpMessageConverter found for response</title>
    <link href="/2020/02/21/springboot-no-suitable-HttpMessageConverter-found-for-response/"/>
    <url>/2020/02/21/springboot-no-suitable-HttpMessageConverter-found-for-response/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在使用<code>springboot</code>调用第三方接口的时候，出现了这个异常Could not extract response: no suitable HttpMessageConverter found for response type [cn.justme.sboot.entity.BaseResp&lt;java.lang.String&gt;] and content type [text/plain;charset=UTF-8],这里就来分析一下具体问题</p></blockquote><h3 id="事件还原"><a href="#事件还原" class="headerlink" title="事件还原"></a>事件还原</h3><h4 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1. pom.xml"></a>1. pom.xml</h4><pre><code class="xml">&lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h4 id="2-feign调用"><a href="#2-feign调用" class="headerlink" title="2. feign调用"></a>2. feign调用</h4><pre><code class="java">@FeignClient(name = &quot;test&quot;, url = &quot;http://localhost:8080&quot;)public interface TestClient {    @GetMapping(&quot;/api/test&quot;)    BaseResp&lt;String&gt; test();}</code></pre><p>三方接口返回的是json，这里我是使用feign调用。</p><h4 id="3-第三方接口"><a href="#3-第三方接口" class="headerlink" title="3. 第三方接口"></a>3. 第三方接口</h4><blockquote><p>接口: <code>/api/test</code></p><pre><code class="json">{    &quot;status&quot;: 0,    &quot;message&quot;: &quot;&quot;,    &quot;data&quot;: null}</code></pre><p><img src="/2020/02/21/springboot-no-suitable-HttpMessageConverter-found-for-response/Xnip2020-02-21_15-00-38.jpg" srcset="/img/loading.gif" alt><br>我们可以看到<code>Content-Type: text/plain;charset=UTF-8</code>,</p></blockquote><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>springboot默认的处理json的<code>HttpMessageConverter</code>为<code>MappingJackson2HttpMessageConverter</code>。</p><pre><code class="java">public MappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {    super(objectMapper, MediaType.APPLICATION_JSON, new MediaType(&quot;application&quot;, &quot;*+json&quot;));}</code></pre><p>但是<code>MappingJackson2HttpMessageConverter</code>只支持<code>APPLICATION_JSON</code>类型,所以springboot没有找到合适的<code>HttpMessageConverter</code>,于是报出了上面的异常。</p><p>feign默认的Decoder为<code>SpringDecoder</code>:</p><pre><code class="java">public class SpringDecoder implements Decoder {    private ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;    public SpringDecoder(ObjectFactory&lt;HttpMessageConverters&gt; messageConverters) {        this.messageConverters = messageConverters;    }}</code></pre><p>我们看一下默认的<code>messageConverters</code><br><img src="/2020/02/21/springboot-no-suitable-HttpMessageConverter-found-for-response/Xnip2020-02-21_15-21-33.jpg" srcset="/img/loading.gif" alt></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><blockquote><p>解决该问题，只要添加<code>MediaType.TEXT_PLAIN</code>类型的支持即可</p></blockquote><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><blockquote><p>仅仅在该<code>FeignClient</code>做<code>MediaType.TEXT_PLAIN</code>的支持，不影响其他的client。<br><code>`</code>java<br>@FeignClient(name = “test”, url = “<a href="http://localhost:8080&quot;" target="_blank" rel="noopener">http://localhost:8080&quot;</a>, configuration = TestClient.FeignTestConfiguration.class)<br>public interface TestClient {<br>    @GetMapping(“/api/test”)<br>    BaseResp<string> test();</string></p></blockquote><pre><code>class FeignTestConfiguration {    @Bean    public Decoder textPlainDecoder() {        return new SpringDecoder(() -&gt; new HttpMessageConverters(new CustomMappingJackson2HttpMessageConverter()));    }}class CustomMappingJackson2HttpMessageConverter extends MappingJackson2HttpMessageConverter {    @Override    public void setSupportedMediaTypes(List&lt;MediaType&gt; supportedMediaTypes) {        super.setSupportedMediaTypes(Collections.singletonList(MediaType.TEXT_PLAIN));    }}</code></pre><p>}</p><pre><code>调用接口，查看该`FeignClient`的`Decoder`![](Xnip2020-02-21_15-29-34.jpg)此时调用成功。#### 方案二&gt; 全局修改，使所有的调用都支持`TEXT_PLAIN`的`Content-Type````java@Configurationpublic class TestConfig {    @Bean    public MappingJackson2HttpMessageConverter customMappingJackson2HttpMessageConverter() {        return new CustomMappingJackson2HttpMessageConverter();    }    static class CustomMappingJackson2HttpMessageConverter extends MappingJackson2HttpMessageConverter {        public CustomMappingJackson2HttpMessageConverter() {            setSupportedMediaTypes(Collections.singletonList(MediaType.TEXT_PLAIN));        }    }}</code></pre><h4 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h4><p>我们也可以实现<code>WebMvcConfigurer</code>下面接口来实现对应功能。</p><pre><code class="java">/**     * Configure the {@link HttpMessageConverter}s to use for reading or writing     * to the body of the request or response. If no converters are added, a     * default list of converters is registered.     * &lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt; that adding converters to the list, turns off     * default converter registration. To simply add a converter without impacting     * default registration, consider using the method     * {@link #extendMessageConverters(java.util.List)} instead.     * @param converters initially an empty list of converters     */    default void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {    }    /**     * A hook for extending or modifying the list of converters after it has been     * configured. This may be useful for example to allow default converters to     * be registered and then insert a custom converter through this method.     * @param converters the list of configured converters to extend.     * @since 4.1.3     */    default void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) {    }</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>链接收藏</title>
    <link href="/2020/02/08/%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/"/>
    <url>/2020/02/08/%E9%93%BE%E6%8E%A5%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>收藏一些较好的技术链接，整理方便查看</p></blockquote><h3 id="一-java基础"><a href="#一-java基础" class="headerlink" title="一. java基础"></a>一. java基础</h3><ul><li><a href="https://www.toutiao.com/i6682990241403372035/?timestamp=1581152961&amp;app=news_article&amp;group_id=6682990241403372035&amp;req_id=2020020817092101012902702013F4CE16" target="_blank" rel="noopener">java基础</a></li><li><a href="https://www.toutiao.com/i6646348468807795214/?timestamp=1581153011&amp;app=news_article&amp;group_id=6646348468807795214&amp;req_id=202002081710110101310760531978D4E6" target="_blank" rel="noopener">java异常</a></li><li><a href="https://www.toutiao.com/i6673515997896376844/?timestamp=1581153031&amp;app=news_article&amp;group_id=6673515997896376844&amp;req_id=2020020817103101012903509107F6019A" target="_blank" rel="noopener">java多线程</a></li><li><a href="https://www.toutiao.com/a6682830757519426055/?timestamp=1581153064&amp;app=news_article&amp;group_id=6682830757519426055&amp;req_id=2020020817110401012903514414EEC039" target="_blank" rel="noopener">java原子操作</a></li></ul><h3 id="二-reactor"><a href="#二-reactor" class="headerlink" title="二. reactor"></a>二. reactor</h3><ul><li><a href="https://projectreactor.io/" target="_blank" rel="noopener">project reactor官网</a></li><li><a href="https://blog.csdn.net/get_set/article/details/79466657" target="_blank" rel="noopener">响应式Spring的道法术器（Spring WebFlux 教程）</a></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Jackson LocalDateTime的反序列化问题</title>
    <link href="/2020/01/05/Jackson-LocalDateTime%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <url>/2020/01/05/Jackson-LocalDateTime%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当我们使用java8的LocalDateTime，LocalDate等接收来自前端请求json的时间字段时，会由于格式问题会导致反序列化失败，这里提供一种全局的解决方案。</p></blockquote><h2 id="1-示例"><a href="#1-示例" class="headerlink" title="1. 示例"></a>1. 示例</h2><h3 id="1-1-代码"><a href="#1-1-代码" class="headerlink" title="1.1 代码"></a>1.1 代码</h3><p><strong>build.gradle</strong></p><pre><code class="gradle">plugins {  id &#39;org.springframework.boot&#39; version &#39;2.1.11.RELEASE&#39;  id &#39;io.spring.dependency-management&#39; version &#39;1.0.8.RELEASE&#39;  id &#39;java&#39;}group = &#39;com.example&#39;version = &#39;0.0.1-SNAPSHOT&#39;sourceCompatibility = &#39;1.8&#39;repositories {  mavenCentral()  maven { url &quot;http://maven.aliyun.com/nexus/content/groups/public&quot; }}dependencies {  implementation &#39;org.springframework.boot:spring-boot-starter-web&#39;  implementation &quot;org.apache.commons:commons-lang3:3.9}&quot;  testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39;}</code></pre><p><strong>java代码</strong></p><pre><code class="java">@Datepublic class ComputeParam {    LocalDateTime createTime;} @PostMapping(&quot;/compute&quot;)public Stirng compute(@RequestBody ComputeParam param) {    return ok;}</code></pre><h3 id="1-2-请求"><a href="#1-2-请求" class="headerlink" title="1.2 请求"></a>1.2 请求</h3><pre><code>curl --request POST \  --url http://localhost:8080/compute \  --header &#39;content-type: application/json&#39; \  --data &#39;{&quot;createTime&quot;: &quot;2020-01-04 12:12:12&quot;}&#39;</code></pre><h3 id="1-3-响应"><a href="#1-3-响应" class="headerlink" title="1.3 响应"></a>1.3 响应</h3><p><strong>异常信息</strong></p><pre><code>2020-01-05 00:41:33.506  WARN [,fa2f61967e660396,fa2f61967e660396,false] 84616 --- [nio-8080-exec-2] .w.s.m.s.DefaultHandlerExceptionResolver : Resolved [org.springframework.http.converter.HttpMessageNotReadableException: JSON parse error: Cannot deserialize value of type `java.time.LocalDateTime` from String &quot;2020-01-04 12:12:12&quot;: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text &#39;2020-01-04 12:12:12&#39; could not be parsed at index 10; nested exception is com.fasterxml.jackson.databind.exc.InvalidFormatException: Cannot deserialize value of type `java.time.LocalDateTime` from String &quot;2020-01-04 12:12:12&quot;: Failed to deserialize java.time.LocalDateTime: (java.time.format.DateTimeParseException) Text &#39;2020-01-04 12:12:12&#39; could not be parsed at index 10 at [Source: (PushbackInputStream); line: 2, column: 16] (through reference chain: cn.justme.justmerule.bean.param.ComputeParam[&quot;createTime&quot;])]</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><blockquote><p>注册自定义LocalDateTimeDeserializer</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="java">// 全局生效@JsonComponentpublic class JsonConfig {    public static class LocalDateTimeDeserializer extends JsonDeserializer&lt;LocalDateTime&gt; {        @Override        public LocalDateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {            if (StringUtils.isNumeric(jsonParser.getValueAsString())) { // 如果是时间戳形式                return new Date(jsonParser.getValueAsLong()).toInstant().atOffset(ZoneOffset.of(&quot;+8&quot;)).toLocalDateTime()            } else { // 默认是yyyy-MM-dd HH:mm:ss 形式，如果有多种格式，可以自行拓展                return LocalDateTime.parse(jsonParser.getValueAsString(), DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))            }        }    }}</code></pre><p><em>关于<code>@JsonComponent</code>参照<a href="https://docs.spring.io/spring-boot/docs/2.2.2.RELEASE/reference/htmlsingle/#boot-features-json-components" target="_blank" rel="noopener">官网</a></em></p><p><strong>如果不想全局生效:</strong></p><ol><li><p>我们可以去掉@JsonComponent注解，然后在ComputeParam实体类上添加@JsonDeserialize，如下：</p><pre><code class="java">@Datepublic class ComputeParam { @JsonDeserialize(using = JsonConfig.LocalDateTimeDeserializer.class) LocalDateTime createTime;}</code></pre><p>这样可以指定特定的<code>Deserializer</code>,而不影响全局其他同类型的字段。</p></li><li><p>更简单的直接在createTime字段上增加<code>@JsonFormat</code>注解即可</p><pre><code class="java">@Datepublic class ComputeParam { @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;) LocalDateTime createTime;}</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>jackson</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring boot配置文件属性转换</title>
    <link href="/2019/08/17/Spring-boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2/"/>
    <url>/2019/08/17/Spring-boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在我们用Springboot进行开发的时候，我们的很多可配置化的参数会写在配置文件内，然后可以用<code>@ConfigurationProperties</code>将其转化为bean在程序中使用。在转化为bean时，Springboot会默认给我提供一系列的Converter进行参数的转化。如字符串和数据类型的转换，Duration和对应字符串的转换等等。但是有时候一些类型的转换springboot并没有提供对应的Converter，那么我们可以自定义，具体见下文。</p></blockquote><p>这周我想在application.yml文件中配置一个工作时间的时间段，比如9:30-18:30，想转化为 LocalTime，但是发现行不通。具体如下：</p><h4 id="一-问题代码"><a href="#一-问题代码" class="headerlink" title="一 问题代码"></a>一 问题代码</h4><ol><li>application.yml</li></ol><pre><code class="yml">demo:  startTime: &quot;09:30:00&quot;  timeout: 2m</code></pre><ol start="2"><li>ConfigProperties.java</li></ol><pre><code class="java">@Data@Component@ConfigurationProperties(prefix = &quot;demo&quot;)public class ConfigProperties {    private LocalTime startTime;    private Duration timeout;}</code></pre><ol start="3"><li>启动报错</li></ol><pre><code class="java">***************************APPLICATION FAILED TO START***************************Description:Failed to bind properties under &#39;demo.start-time&#39; to java.time.LocalTime:    Property: demo.starttime    Value: 09:30:00    Origin: class path resource [application.yml]:2:14    Reason: failed to convert java.lang.String to java.time.LocalTimeAction:Update your application&#39;s configuration</code></pre><h4 id="二-解决报错"><a href="#二-解决报错" class="headerlink" title="二 解决报错"></a>二 解决报错</h4><p>首先，当然我们可以用String来接<code>startTime</code>的值，然后在代码中自己在将其转为LocalTime，这样做也行，但是会存在一个问题，如果我不小心将<code>startTime</code>的值配置错了，比如配成了”08:3o:00”(其中一个0配置了字母o)。这时程序启动是不会报错的，只有程序运行到你的转换代码才会报错，我们需要避免在系统运行时才发现错误，防止对应的生产问题。</p><p>既然错误提示已经给出无法将String转为LocalTime，那么我们可以自定义Converter，只需要两步：</p><ol><li>实现<strong><code>Converter</code></strong>接口</li><li>用<strong>@ConfigurationPropertiesBinding</strong>注册自定义的<code>Converter</code></li></ol><p>自定义<code>Converter</code>:</p><pre><code class="java">import org.springframework.boot.context.properties.ConfigurationPropertiesBinding;import org.springframework.core.convert.converter.Converter;import org.springframework.stereotype.Component;import java.time.LocalTime;import java.util.Objects;@Component@ConfigurationPropertiesBindingpublic class LocalTimeConverter implements Converter&lt;String, LocalTime&gt; {    @Override    public LocalTime convert(String source) {        Objects.requireNonNull(source);        return LocalTime.parse(source);    }}</code></pre><p>好了，万事俱备，启动程序：</p><pre><code>2019-08-17 17:23:39.902  INFO 27553 --- [on(2)-127.0.0.1] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring DispatcherServlet &#39;dispatcherServlet&#39;2019-08-17 17:23:39.902  INFO 27553 --- [on(2)-127.0.0.1] o.s.web.servlet.DispatcherServlet        : Initializing Servlet &#39;dispatcherServlet&#39;2019-08-17 17:23:39.912  INFO 27553 --- [on(2)-127.0.0.1] o.s.web.servlet.DispatcherServlet        : Completed initialization in 9 ms</code></pre><p>大公告成，遇到相同问题的朋友可以自己动手实现自己的Converter了。</p>]]></content>
    
    
    <categories>
      
      <category>spring boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapStruct ——An annotation processor for generating type-safe bean mappers</title>
    <link href="/2019/08/10/MapStruct-%E2%80%94%E2%80%94An-annotation-processor-for-generating-type-safe-bean-mappers/"/>
    <url>/2019/08/10/MapStruct-%E2%80%94%E2%80%94An-annotation-processor-for-generating-type-safe-bean-mappers/</url>
    
    <content type="html"><![CDATA[<blockquote><p>bean对象之间的相互映射的工具有不少，比如常见的BeanUtils，dozer，这都基本都是基于反射实现的，但是MapStruct则不同，下面我们就来看看MapStruct的使用方法吧！</p></blockquote><p>MapStruct类似lombok，在编译期生成基于转换规则的 Impl 文件，运行时直接调用 Impl 文件中的函数。所以它的速度是比其他基于反射实现的工具速度要快！！！</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1 pom.xml"></a>1 pom.xml</h5><pre><code class="xml">&lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;org.mapstruct.version&gt;1.3.0.Final&lt;/org.mapstruct.version&gt;        &lt;org.projectlombok.version&gt;1.18.8&lt;/org.projectlombok.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;version&gt;${org.projectlombok.version}&lt;/version&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;junit&lt;/groupId&gt;            &lt;artifactId&gt;junit&lt;/artifactId&gt;            &lt;version&gt;4.12&lt;/version&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;            &lt;artifactId&gt;mapstruct&lt;/artifactId&gt;            &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.0&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;1.8&lt;/source&gt;                    &lt;target&gt;1.8&lt;/target&gt;                    &lt;annotationProcessorPaths&gt;                        &lt;path&gt;                            &lt;groupId&gt;org.mapstruct&lt;/groupId&gt;                            &lt;artifactId&gt;mapstruct-processor&lt;/artifactId&gt;                            &lt;version&gt;${org.mapstruct.version}&lt;/version&gt;                        &lt;/path&gt;                        &lt;path&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                            &lt;version&gt;${org.projectlombok.version}&lt;/version&gt;                        &lt;/path&gt;                    &lt;/annotationProcessorPaths&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><h5 id="2-实体"><a href="#2-实体" class="headerlink" title="2 实体"></a>2 实体</h5><pre><code class="java">@Datapublic class Source {    private String name;    private String alias;    private Car car;    @Data    public static class Car {        private String color;    }}@Datapublic class Target {    private String name;    private String anotherName;    private Car car;    @Data    public static class Car {        private String color;    }}</code></pre><h5 id="3-转换"><a href="#3-转换" class="headerlink" title="3 转换"></a>3 转换</h5><pre><code class="java">@Mapperpublic interface SourceConvert {    // field不一致的，可以使用@Mapping来指定映射关系    @Mapping(source = &quot;alias&quot;, target = &quot;anotherName&quot;)    Target sourceToTarget(Source source);}</code></pre><h5 id="4-使用"><a href="#4-使用" class="headerlink" title="4 使用"></a>4 使用</h5><pre><code class="java">public class SourceConvertTest {    SourceConvert sourceConvert = null;    @Before    public void init() {        sourceConvert = Mappers.getMapper(SourceConvert.class);    }    @Test    public void sourceToTarget() {        Source source = new Source();        source.setName(&quot;jack&quot;);        source.setAlias(&quot;mini&quot;);        Source.Car car = new Source.Car();        car.setColor(&quot;black&quot;);        source.setCar(car);        Target target = sourceConvert.sourceToTarget(source);        // Target(name=jack, anotherName=mini, car=Target.Car(color=black))        System.out.println(target);    }}</code></pre><p>到这转换已经结束。因为MapStruct是在编译期生成基于转换规则 Impl 文件，所以我们是可以看到编译后生成的SourceConvertImpl的，如下：</p><pre><code class="java">public class SourceConvertImpl implements SourceConvert {    public SourceConvertImpl() {    }    public Target sourceToTarget(Source source) {        if (source == null) {            return null;        } else {            Target target = new Target();            target.setAnotherName(source.getAlias());            target.setName(source.getName());            target.setCar(this.carToCar(source.getCar()));            return target;        }    }    protected Car carToCar(cn.justme.common.Source.Car car) {        if (car == null) {            return null;        } else {            Car car1 = new Car();            car1.setColor(car.getColor());            return car1;        }    }}</code></pre><p>所以我们可以很清楚的看到内部转换的逻辑，当转换出现问题时，MapStruct比一些其他工具类更易debug，定位问题。更多功能可以参考官方文档。</p><h5 id="5-优势"><a href="#5-优势" class="headerlink" title="5 优势"></a>5 优势</h5><p>总结几点优势：</p><ol><li>速度快</li><li>类型安全</li><li>定位问题更方便</li><li>Event handling (<code>@BeforeMapping, @AfterMapping</code>）</li></ol><p>参考：</p><p><a href="http://mapstruct.org/documentation/stable/reference/html/" target="_blank" rel="noopener">官网</a></p><p><a href="https://dozermapper.github.io/gitbook/" target="_blank" rel="noopener">dozer</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java8 Lambda Handling Exceptions</title>
    <link href="/2019/07/27/Java8-Lambda-Handling-Exceptions/"/>
    <url>/2019/07/27/Java8-Lambda-Handling-Exceptions/</url>
    
    <content type="html"><![CDATA[<blockquote><p>lambda表达式有利于我们写出非常简洁的代码，但是Java8中lambda表达式无法抛出受检异常，这样会使我们在lambda表达式中使用抛出Checked Exception的方法时，会出现一些问题，接下来我们就来探讨一下这个问题。</p></blockquote><h3 id="一-问题"><a href="#一-问题" class="headerlink" title="一 问题"></a>一 问题</h3><p>首先看一下出现问题的代码：</p><pre><code class="java">// 获取文件里的文本内容public Stream&lt;String&gt; readFiles(String path) throws IOException {        return Files.lines(Paths.get(getClass().getClassLoader().getResource(path).getPath()));    }public void test3() {        Stream.of(&quot;a.txt&quot;)                .flatMap(this::readFiles) // 这里会出现编译异常                .forEach(System.out::println);    }</code></pre><p>到这里，我们就会发现一个编译问题：</p><pre><code>Error:(64, 26) java: 方法引用中抛出的类型java.io.IOException不兼容</code></pre><p>这是由于<code>flatMap()</code>支持的函数式接口</p><pre><code class="java">@FunctionalInterfacepublic interface Function&lt;T, R&gt; {    /**     * 并不支持抛出异常（没有申明throw）     * Applies this function to the given argument.     *     * @param t the function argument     * @return the function result     */    R apply(T t);}</code></pre><h3 id="二-问题"><a href="#二-问题" class="headerlink" title="二 问题"></a>二 问题</h3><p>处理这种受检异常时，我们可以先捕获，然后包装并抛出一个非受检异常。</p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><pre><code class="java">public void test1() {    Stream.of(&quot;a.txt&quot;)            .flatMap(path -&gt; {                try {                    return readFiles(path);                } catch (IOException e) {                    e.printStackTrace();                    throw new RuntimeException();                }            })            .forEach(System.out::println);}</code></pre><p>这样可以解决问题，但是会损失lambda的简洁性。</p><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>出现编译时异常的主要问题还是由于Function的apply方法不支持抛出异常，我们可以定义自己的函数式接口：</p><pre><code class="java">@FunctionalInterfacepublic interface ThrowingFunction&lt;T,R,E extends Throwable&gt; {    R apply(T arg) throws E;}</code></pre><p>然后在使用一个包装器</p><pre><code class="java">static &lt;T, R, E extends Exception&gt; Function&lt;T, R&gt; unchecked(ThrowingFunction&lt;T, R, E&gt; f) {        return t -&gt; {            try {                return apply(t);            } catch (final Throwable e) {                throw new WrappedException(e);            }        };}</code></pre><p>然后就可以这样使用了：</p><pre><code class="java">@Test    public void test5() {        Stream.of(&quot;a.txt&quot;)                .flatMap(unchecked(this::readFiles))                .forEach(System.out::println);    }</code></pre><p>这样的话就保证了代码的间接性，但是我们又不得不定义对应的函数式接口和对应的包装器。对于这个问题，我们可以利用一个开源库<code>ThrowingFunction</code>来解决。方法如下：</p><p>1 添加依赖</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;pl.touk&lt;/groupId&gt;  &lt;artifactId&gt;throwing-function&lt;/artifactId&gt;  &lt;version&gt;1.3&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2 代码</p><pre><code class="java">@Testpublic void test4() {  Stream.of(&quot;a.txt&quot;)    .flatMap(ThrowingFunction.unchecked(this::readFiles))    .forEach(System.out::println);}</code></pre><p>到此为止，我们可以<code>ThrowingFunction</code>很好的解决这种检测异常问题！</p>]]></content>
    
    
    
    <tags>
      
      <tag>lambda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次由spring-boot-devtools引发的类型转换问题</title>
    <link href="/2019/07/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B1spring-boot-devtools%E5%BC%95%E5%8F%91%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/"/>
    <url>/2019/07/20/%E8%AE%B0%E4%B8%80%E6%AC%A1%E7%94%B1spring-boot-devtools%E5%BC%95%E5%8F%91%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在我们在用Springboot开发的时候，可能会引入spring-boot-devtools包，因为这个开发工具包提供了很多很好的供开发时使用的功能，比如提供一些默认的配置，自动重启，远程应用等。但是今天我就碰到了一个与它相关的问题，困扰了我不少时间。</p></blockquote><h3 id="一-简介"><a href="#一-简介" class="headerlink" title="一 简介"></a>一 简介</h3><p><code>spring-boot-devtools</code>为<code>Spring Boot</code>包含的一组额外的工具，可以使应用程序开发体验更加愉快。该<code>spring-boot-devtools</code>模块可以包含在任何项目中，以提供额外的开发期间功能。<code>Spring Boot</code>为了使开发者在开发时针对文件的修改能快速的生效，在<code>spring-boot-devtools</code>中就提供了一个自动重启的功能，只要类路径上的文件发生更改，就会自动重新启动应用程序。</p><p>Spring Boot提供的重启技术使用两个类加载器。不更改的类（例如，来自第三方jar的类）将加载到基类加载器中。您正在积极开发的类将加载到RestartClassLoader加载器中。重新启动应用程序时，RestartClassLoader加载器会被丢弃并重新创建一个。这种方法意味着应用程序重新启动通常比“冷启动”快得多，因为<em>基本</em>类加载器加载的类已经可用。</p><h3 id="二-问题"><a href="#二-问题" class="headerlink" title="二 问题"></a>二 问题</h3><p>我在使用dozer来进行bean的映射的时候，报出了一个<code>ClassCastException</code>异常。代码如下</p><pre><code class="java">Mapper mapper = DozerBeanMapperBuilder.create()  .withMappingBuilder(new BeanMappingBuilder() {    @Override    protected void configure() {      mapping(type(ZxCreditReportDTO.class), type(CreditInfoDetailDTO.class)             ).fields(field(&quot;username&quot;), field(&quot;name&quot;));    }  }).build();CreditInfoDetailDTO map = mapper.map(creditReportDTO, CreditInfoDetailDTO.class);</code></pre><p>首先这段代码在Main函数或者在单元测试类运行良好，但是当我启动springboot通过http接口去调用这段代码却出现如下错误：</p><p><img src="/2019/07/20/记一次由spring-boot-devtools引发的类型转换问题/1.jpg" srcset="/img/loading.gif" alt="ClassCastException"></p><p>这里奇怪的就是居然出现类同一个类<code>CreditInfoDetailDTO</code>转换的异常，相同的类为什么会出现类型转换异常呢？于是就出现两个疑问，一，为什么用Main函数或者Junit单元测试没有出现问题？二，什么同一个类会出现类型转换异常？</p><h3 id="三-原因"><a href="#三-原因" class="headerlink" title="三 原因"></a>三 原因</h3><p>其实原因就是启动Springboot调接口与Main函数测试使用的类加载器是有差别的。使用Main函数的时候<code>CreditInfoDetailDTO</code>类都是由AppClassLoader加载器加载的。而springboot由于添加了spring-boot-devtools依赖，会有所不同。上面有这么一段代码：</p><pre><code class="java"> mapping(type(ZxCreditReportDTO.class), type(CreditInfoDetailDTO.class)             ).fields(field(&quot;username&quot;), field(&quot;name&quot;));</code></pre><p>进入这段代码内部，会调用MappingUtils的loadClass(String name, BeanContainer beanContainer)去加载指定的mapping类。</p><p>代码如下：</p><pre><code class="java">public static Class&lt;?&gt; loadClass(String name, BeanContainer beanContainer) {  DozerClassLoader loader = beanContainer.getClassLoader();  return loader.loadClass(name);}</code></pre><p>继续查看<code>beanContainer.getClassLoader()</code></p><pre><code class="java">public class BeanContainer {      // 这一段    DozerClassLoader classLoader = new DefaultClassLoader(getClass().getClassLoader());    public DozerClassLoader getClassLoader() {        return classLoader;    }  ...</code></pre><p>这里Dozer默认使用的加载器为DefaultClassLoader，而DefaultClassLoader内部有一个ClassLoader属性，这个属性值就是上面的<code>getClass().getClassLoader()</code>。由此可以知道加载CreditInfoDetailDTO的加载器与加载BeanContainer类的加载器是同一个都是AppClassLoader，由于spring-boot-devtools的作用，<code>CreditInfoDetailDTO map = mapper.map(creditReportDTO, CreditInfoDetailDTO.class);</code>左侧的CreditInfoDetailDTO是由RestartClassLoader加载的，所以是由于不同的类加载器加载从而导致类型转换异常。</p><h3 id="四-解决方案"><a href="#四-解决方案" class="headerlink" title="四 解决方案"></a>四 解决方案</h3><h4 id="1-不使用spring-boot-devtools"><a href="#1-不使用spring-boot-devtools" class="headerlink" title="1 不使用spring-boot-devtools"></a>1 不使用spring-boot-devtools</h4><h4 id="2-使用spring-devtools-properties"><a href="#2-使用spring-devtools-properties" class="headerlink" title="2 使用spring-devtools.properties"></a>2 使用spring-devtools.properties</h4><p>在reources目录下新建META-INF文件夹，再在META-INF下新建spring-devtools.properties，如下：</p><pre><code class="properties"># 支持正则restart.include.dozer=/dozer-[\\w\\d-\.]+\.jar</code></pre><p>更多配置信息参考<a href="https://docs.spring.io/spring-boot/docs/2.1.6.RELEASE/reference/html/using-boot-devtools.html#using-boot-devtools-customizing-classload" target="_blank" rel="noopener">官方文档</a></p><p>这个配置就是dozer-[\w\d-.]+.jar里的类也使用RestartClassLoader加载器加载，这样就不会出现类型转换问题了。</p><blockquote><p> <em>注意：当然其实在生产环境我们是不建议使用spring-boot-devtools的。在运行完全打包的应用程序时会自动禁用，如果您的应用程序是从<code>java -jar</code>特殊的类加载器启动或启动的，那么它将被视为“生产应用程序”。如果这不适用（即，如果您从容器运行应用程序），请考虑排除devtools或设置<code>-Dspring.devtools.restart.enabled=false</code>系统属性。</em></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Feign配置易错点</title>
    <link href="/2019/07/13/Feign%E9%85%8D%E7%BD%AE%E6%98%93%E9%94%99%E7%82%B9/"/>
    <url>/2019/07/13/Feign%E9%85%8D%E7%BD%AE%E6%98%93%E9%94%99%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在我们利用spring-cloud-openfeign的时候，不同的client可能需要一些自定义的配置，我们可以在配置文件中配置，也可以写相应的配置类。而写配置类有一个易掉的坑，接下来就来讲解一下这个坑以及解决方案！</p></blockquote><p>先来看一段常见的代码。</p><h3 id="一-代码"><a href="#一-代码" class="headerlink" title="一 代码"></a>一 代码</h3><pre><code class="java">@FeignClient(name = &quot;${feign.name}&quot;, url = &quot;${feign.url}&quot;, configuration=FooConfiguration.class)public interface FooClient {    @GetMapping(&quot;/users/{id}&quot;)    User findById(@PathVariable(&quot;id&quot;) Long id);    /**     * 注意：     * 1. 该类可以独立出去；     * 2. 该类上也可添加@Configuration声明是一个配置类；     * 配置类上也可添加@Configuration注解，声明这是一个配置类；     * 但此时千万别将该放置在主应用程序上下文@ComponentScan所扫描的包中，     * 否则，该配置将会被所有Feign Client共享，无法实现细粒度配置！     */    @Configuration    public class FooConfiguration {        @Bean        public Contract feignContract() {            return new feign.Contract.Default();        }        @Bean        public BasicAuthRequestInterceptor basicAuthRequestInterceptor() {            return new BasicAuthRequestInterceptor(&quot;user&quot;, &quot;password&quot;);        }    }}</code></pre><p>上面的配置是我从<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.1.2.RELEASE/single/spring-cloud-openfeign.html#spring-cloud-feign-overriding-defaults" target="_blank" rel="noopener">官网</a>直接copy下来的。这样写，产生的效果是什么？如果配置类在<code>@ComponentScan</code>扫描路径，则该配置默认会全局生效。所以如果不仔细看一下官方文档，很容易进坑，官方文档也给出了注意点：</p><blockquote><p>FooConfiguration does not need to be annotated with @Configuration. However, if it is, then take care to exclude it from any @ComponentScan that would otherwise include this configuration as it will become the default source for feign.Decoder, feign.Encoder, feign.Contract, etc., when specified. This can be avoided by putting it in a separate, non-overlapping package from any @ComponentScan or @SpringBootApplication, or it can be explicitly excluded in @ComponentScan.</p></blockquote><p><strong>为达到目的，可以直接去掉<code>FooConfiguration</code>类上的<code>@Configuration</code>注解。</strong></p><h3 id="二-总结"><a href="#二-总结" class="headerlink" title="二 总结"></a>二 总结</h3><ul><li>配置类上也可添加<code>@Configuraiton</code> 注解，声明这是一个配置类；但此时千万别将该放置在主应用程序上下文<code>@ComponentScan</code> 所扫描的包中，<strong>否则，该配置将会被所有Feign Client共享</strong>（相当于变成了通用配置，其实本质还是Spring父子上下文扫描包重叠导致的问题），无法实现细粒度配置！</li><li>可以直接采用配置文件的配置方式（Edgware开始提供）</li></ul>]]></content>
    
    
    <categories>
      
      <category>feign</category>
      
    </categories>
    
    
    <tags>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Using Optional with Jackson</title>
    <link href="/2019/07/06/Using-Optional-with-Jackson/"/>
    <url>/2019/07/06/Using-Optional-with-Jackson/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在java8的时候，针对NOP异常，提供了Optional的解决方案。但是你了解Jackson序列化含Optional字段的POJO时会发生什么吗？在本文中，将介绍Optional类，然后解释在与Jackson一起使用时可能遇到的一些问题。接下来，我们将介绍一个解决方案，让Jackson将Optional视为普通的可空对象。</p></blockquote><h3 id="1-引入Jackson"><a href="#1-引入Jackson" class="headerlink" title="1 引入Jackson"></a>1 引入Jackson</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;    &lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2-实体类"><a href="#2-实体类" class="headerlink" title="2 实体类"></a>2 实体类</h3><pre><code class="java">public class User {    private String username;    private Optional&lt;String&gt; nickName;    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public Optional&lt;String&gt; getNickName() {        return nickName;    }    public void setNickName(Optional&lt;String&gt; nickName) {        this.nickName = nickName;    }}</code></pre><p><em>请记住，Optionals不应该用作属性，这里这样做是为了说明问题。</em></p><h3 id="3-序列化"><a href="#3-序列化" class="headerlink" title="3 序列化"></a>3 序列化</h3><pre><code class="java">public class JacksonTest {    private ObjectMapper mapper;    @Before    public void init() {        mapper = new ObjectMapper();    }    @Test    public void test1() throws JsonProcessingException {        User user = new User();        user.setUsername(&quot;SHIV&quot;);        user.setNickName(Optional.of(&quot;JACK&quot;));        String result = mapper.writeValueAsString(user);        System.out.println(result);    }}</code></pre><p>输出结果:</p><pre><code class="javascript">{&quot;username&quot;:&quot;SHIV&quot;,&quot;nickName&quot;:{&quot;present&quot;:true}}</code></pre><p>虽然这可能看起来很奇怪，但是这就是实际的结果。在这种情况下，isPresent()是Optional类的公共getter 。这意味着它将使用值true或false进行序列化，具体取决于它是否为空。这是Jackson的默认序列化行为。但是通常这不是我们想要的结果，我们需要的是nickName的实际值”JACK”。</p><h3 id="4-反序列化"><a href="#4-反序列化" class="headerlink" title="4 反序列化"></a>4 反序列化</h3><p>让我们将上面的输出结果反序列化一下，看看结果：</p><pre><code class="java">@Testpublic void test2() throws IOException {    String json = &quot;{\&quot;username\&quot;:\&quot;SHIV\&quot;,\&quot;nickName\&quot;:{\&quot;present\&quot;:true}}&quot;;    User result = mapper.readValue(json, User.class);}</code></pre><p>发生异常，输出结果：</p><pre><code>com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field &quot;present&quot; (class java.util.Optional), not marked as ignorable (0 known properties: ]) at [Source: (String)&quot;{&quot;username&quot;:&quot;SHIV&quot;,&quot;nickName&quot;:{&quot;present&quot;:true}}&quot;; line: 1, column: 46] (through reference chain: cn.justme.lockdemo.User[&quot;nickName&quot;]-&gt;java.util.Optional[&quot;present&quot;])    at com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException.from(UnrecognizedPropertyException.java:61)    ...</code></pre><p>jackson无法识别present字段.<br>如果用<code>String json = &quot;{\&quot;username\&quot;:\&quot;SHIV\&quot;,\&quot;nickName\&quot;:\&quot;JACK\&quot;}&quot;;</code>来反序列化，依然不会成功。</p><h3 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5 解决方案"></a>5 解决方案</h3><p>我们想要的是让Jackson将空的Optional视为null，并将当前的Optional视为表示其值的字段。幸运的是，这个问题已经解决了。Jackson有一组处理JDK 8数据类型的模块，包括Optional。</p><h4 id="5-1-maven依赖"><a href="#5-1-maven依赖" class="headerlink" title="5.1 maven依赖"></a>5.1 maven依赖</h4><pre><code class="xml">&lt;dependency&gt;   &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt;   &lt;artifactId&gt;jackson-datatype-jdk8&lt;/artifactId&gt;   &lt;version&gt;2.9.6&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>接着，我们需要做的就是使用ObjectMapper注册模块</p><pre><code class="javas">ObjectMapper mapper = new ObjectMapper();mapper.registerModule(new Jdk8Module());</code></pre><h4 id="5-2-序列化"><a href="#5-2-序列化" class="headerlink" title="5.2 序列化"></a>5.2 序列化</h4><pre><code class="java">public class Common1 {    private ObjectMapper mapper;    @Before    public void init() {        mapper = new ObjectMapper();        mapper.registerModule(new Jdk8Module());    }    @Test    public void test1() throws JsonProcessingException {        User user = new User();        user.setUsername(&quot;SHIV&quot;);        user.setNickName(Optional.of(&quot;JACK&quot;));        String result = mapper.writeValueAsString(user);        System.out.println(result);        user.setNickName(Optional.empty());        String result1 = mapper.writeValueAsString(user);        System.out.println(result1);    }}</code></pre><p>输出结果</p><pre><code>{&quot;username&quot;:&quot;SHIV&quot;,&quot;nickName&quot;:&quot;JACK&quot;}{&quot;username&quot;:&quot;SHIV&quot;,&quot;nickName&quot;:null}</code></pre><h4 id="5-4-反序列化"><a href="#5-4-反序列化" class="headerlink" title="5.4 反序列化"></a>5.4 反序列化</h4><pre><code class="java">@Testpublic void test2() throws IOException {    String json1 = &quot;{\&quot;username\&quot;:\&quot;SHIV\&quot;,\&quot;nickName\&quot;:\&quot;JACK\&quot;}&quot;;    User result1 = mapper.readValue(json1, User.class);    assertThat(result1.getNickName()).isEqualTo(Optional.of(&quot;JACK&quot;));    String json2 = &quot;{\&quot;username\&quot;:\&quot;SHIV\&quot;,\&quot;nickName\&quot;:null}&quot;;    User result2 = mapper.readValue(json2, User.class);    assertThat(result2.getNickName()).isEmpty();}</code></pre><p>单元测试成功！</p>]]></content>
    
    
    <categories>
      
      <category>jackson</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot 2实现分布式锁</title>
    <link href="/2019/06/29/Spring-Boot-2%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <url>/2019/06/29/Spring-Boot-2%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>随着应用的分布式部署，有很多新的问题需要考虑解决，分布式锁就是其中一个。目前我们的项目中分布式锁是采用zk来实现的。其实Spring早就提供了分布式锁的实现。早期，分布式锁的相关代码存在于Spring Cloud的子项目Spring Cloud Cluster中，后来被迁到Spring Integration中。</p></blockquote><p>先说一下Spring Integration，这是一个企业集成模式的实现,通俗地说，Spring Integration的定位是一个轻量级的ESB，尽管它做了很多ESB不做的事情，而且Spring Cloud Stream的底层也是Spring Integration。Spring Integration提供的全局锁目前为如下存储提供了实现：</p><ul><li>Gemfire</li><li>jdbc</li><li>Redis</li><li>Zookeeper  </li></ul><p>它们使用相同的API抽象，这意味着，不论使用哪种存储，你的编码体验是一样的，有一天想更换实现，只需要修改依赖和配置就可以了，无需修改代码。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><blockquote><p>以redis实现为例    </p></blockquote><p><strong>1 pom.xml</strong></p><pre><code class="xml">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;properties&gt;    &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-integration&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.integration&lt;/groupId&gt;        &lt;artifactId&gt;spring-integration-redis&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;        &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;optional&gt;true&lt;/optional&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p><strong>2 application.properties</strong>  </p><pre><code class="properties">server.port=8080spring.redis.host=localhostspring.redis.port=6379spring.redis.password=123456</code></pre><p><strong>3 LockConfiguration.java</strong>  </p><pre><code class="java">@Configurationpublic class LockConfiguration {    @Bean    public RedisLockRegistry redisLockRegistry(RedisConnectionFactory redisConnectionFactory) {        return new RedisLockRegistry(redisConnectionFactory, &quot;spring-boot&quot;, 5000L);    }}</code></pre><p><strong>4 TestController.java</strong></p><pre><code class="java">@Slf4j@RestControllerpublic class TestController {    @Autowired    private RedisLockRegistry redisLockRegistry;    @GetMapping(&quot;test&quot;)    public void test() throws InterruptedException {        Lock lock = redisLockRegistry.obtain(&quot;lock&quot;);        boolean b1 = lock.tryLock(3, TimeUnit.SECONDS);        log.info(&quot;b1 is : {}&quot;, b1);        TimeUnit.SECONDS.sleep(5);        boolean b2 = lock.tryLock(3, TimeUnit.SECONDS);        log.info(&quot;b2 is : {}&quot;, b2);        lock.unlock();        lock.unlock();    }}</code></pre><p><strong>5 测试</strong><br>首先我们启动两个实例，一个在8080端口，一个在8088端口。<br>在idea里可以直接启动两个实例(默认不行)，第一个正常启动就OK，第二个需要进行一些设置，如图：<br><img src="/2019/06/29/Spring-Boot-2实现分布式锁/1.jpg" srcset="/img/loading.gif" alt><br><img src="/2019/06/29/Spring-Boot-2实现分布式锁/2.jpg" srcset="/img/loading.gif" alt><br>先请求 <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a><br>然后迅速请求 <a href="http://localhost:8088/test" target="_blank" rel="noopener">http://localhost:8088/test</a><br>日志<br>端口8080的日志</p><pre><code class="bash">2019-06-29 18:02:26.809  INFO 5487 --- [nio-8080-exec-3] c.j.lockdemo.controller.TestController   : b1 is : true2019-06-29 18:02:31.821  INFO 5487 --- [nio-8080-exec-3] c.j.lockdemo.controller.TestController   : b2 is : true</code></pre><p>端口8088的日志</p><pre><code class="bash">2019-06-29 18:02:31.311  INFO 5503 --- [io-8088-exec-10] c.j.lockdemo.controller.TestController   : b1 is : false2019-06-29 18:02:36.334  INFO 5503 --- [io-8088-exec-10] c.j.lockdemo.controller.TestController   : b2 is : true2019-06-29 18:02:36.354 ERROR 5503 --- [io-8088-exec-10] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalStateException: You do not own lock at spring-boot:lock] with root causejava.lang.IllegalStateException: You do not own lock at spring-boot:lock    at org.springframework.integration.redis.util.RedisLockRegistry$RedisLock.unlock(RedisLockRegistry.java:305) ~[spring-integration-redis-5.1.6.RELEASE.jar:5.1.6.RELEASE]    at cn.justme.lockdemo.controller.TestController.test(TestController.java:35) ~[classes/:na]    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_181]    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_181]    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_181]    at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_181]    at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:892) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:797) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1039) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:942) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1005) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:897) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at javax.servlet.http.HttpServlet.service(HttpServlet.java:634) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:882) ~[spring-webmvc-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at javax.servlet.http.HttpServlet.service(HttpServlet.java:741) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:53) ~[tomcat-embed-websocket-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:92) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:93) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:200) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:109) ~[spring-web-5.1.8.RELEASE.jar:5.1.8.RELEASE]    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:202) ~[tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:490) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:139) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:92) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:74) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:343) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:408) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:853) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1587) [tomcat-embed-core-9.0.21.jar:9.0.21]    at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) [tomcat-embed-core-9.0.21.jar:9.0.21]    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) [na:1.8.0_181]    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) [na:1.8.0_181]    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) [tomcat-embed-core-9.0.21.jar:9.0.21]    at java.lang.Thread.run(Thread.java:748) [na:1.8.0_181]</code></pre><p>说明第二个实例没有拿到锁，证明了分布式锁的存在。</p><p>参考：<br><a href="http://www.itmuch.com/spring-boot/global-lock/" target="_blank" rel="noopener">Spring Boot 2实现分布式锁——这才是实现分布式锁的正确姿势</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>spring boot</tag>
      
      <tag>分布式锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解Java虚拟机-第三章导图</title>
    <link href="/2019/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AF%BC%E5%9B%BE/"/>
    <url>/2019/06/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA-%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AF%BC%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》，看到第三章——垃圾收集器与内存分配策略，在看的时候整理了个思维导图，于是分享一下。<br><img src="/2019/06/22/深入理解Java虚拟机-第三章导图/垃圾收集器与内存分配策略.png" srcset="/img/loading.gif" alt></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>深入理解Java虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea中解决maven包冲突的问题</title>
    <link href="/2019/06/01/idea%E4%B8%AD%E8%A7%A3%E5%86%B3maven%E5%8C%85%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2019/06/01/idea%E4%B8%AD%E8%A7%A3%E5%86%B3maven%E5%8C%85%E5%86%B2%E7%AA%81%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在我们使用maven进行jar包管理的时候，因为jar包传递依赖，可能会导致相同jar包的不同版本被依赖，由于包管理的依赖优先级会导致最终实际引入的jar包不是你最终需要的版本，由此可能出现类找不到的情况。针对这种jar包冲突的问题，可以依赖idea来很好的解决。</p></blockquote><p>这边展示两种解决问题的方法，一种利用idea自带的<code>show dependencies</code>,另一种是<code>maven helper</code>插件。</p><h2 id="一-show-dependencies"><a href="#一-show-dependencies" class="headerlink" title="一 show dependencies"></a>一 show dependencies</h2><p>打开pom.xml文件，如下图操作：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_18-37-53.jpg" srcset="/img/loading.gif" alt></p><p>选择<code>show dependencies</code>,则会展示项目的jar包依赖图：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_18-40-21.jpg" srcset="/img/loading.gif" alt></p><p>看图中出现的红线，则表明出现了jar包冲突（依赖太多确实观察不太爽）。找到有冲突的jar包，按Ctrl + F搜索，回车查看结果。例如：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_18-37-52.jpg" srcset="/img/loading.gif" alt></p><p>图中虚红线表示该依赖其实是指向了另外的一个版本；实红线，表示该依赖其实有多个不同的版本。此时，找到你想排出的版本，右键操作如下：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_18-54-51.jpg" srcset="/img/loading.gif" alt></p><p>此时pom.xml文件会自动更新如下：</p><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-zookeeper-discovery&lt;/artifactId&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;artifactId&gt;guava&lt;/artifactId&gt;                    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;                &lt;/exclusion&gt;            &lt;/exclusions&gt;        &lt;/dependency&gt;</code></pre><h2 id="二-maven-helper"><a href="#二-maven-helper" class="headerlink" title="二 maven helper"></a>二 maven helper</h2><p><code>maven helper</code>是一款idea插件，首先安装：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_19-24-51.jpg" srcset="/img/loading.gif" alt></p><p>安装好之后，打开pom.xml文件，可以在左下角看到如下标签：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_19-26-59.jpg" srcset="/img/loading.gif" alt></p><p>单击这个标签，出现如下图：</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_19-32-03.jpg" srcset="/img/loading.gif" alt></p><p>选中右键就可以 Exclude 啦，就可以把不需要的版本的Exclude掉。</p><p><img src="/2019/06/01/idea中解决maven包冲突的问题/Xnip2019-02-23_19-33-59.jpg" srcset="/img/loading.gif" alt></p><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h2><p>从使用上来看，还是使用<code>maven helper</code>更方便快捷，利用idea的<code>show dependencies</code>图太大，不好观察操作。<em>很可惜的就是如果用gradle来管理依赖的话，我并没有找到类似的插件。</em></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>用TaskDecorator复制MDC数据到@Async线程</title>
    <link href="/2019/06/01/%E7%94%A8TaskDecorator%E5%A4%8D%E5%88%B6MDC%E6%95%B0%E6%8D%AE%E5%88%B0-Async%E7%BA%BF%E7%A8%8B/"/>
    <url>/2019/06/01/%E7%94%A8TaskDecorator%E5%A4%8D%E5%88%B6MDC%E6%95%B0%E6%8D%AE%E5%88%B0-Async%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这主要涉及父子线程传值的问题，以及当配置@Async应用线程池时，如果得到MDC数据。参考<a href="https://moelholm.com/2017/07/24/spring-4-3-using-a-taskdecorator-to-copy-mdc-data-to-async-threads/" target="_blank" rel="noopener">原文</a></p></blockquote><p>这篇博文主要展示如何从web线程里复制MDC数据到@Async注解的线程里，我们将会使用一个全新的 Spring Framework 4.3的特性: ThreadPoolTaskExecutor#setTaskDecorator() [set-task-decorator]. 如下图：</p><p><img src="/2019/06/01/用TaskDecorator复制MDC数据到-Async线程/Xnip2018-12-08_15-50-55.jpg" srcset="/img/loading.gif" alt></p><p>注意到倒数第一行和第三行：在这个log级别上输出了[随机数]，倒数第三行是在一个web线程里发出的，倒数第一行是在一个用了@Async注解的异步线程里发出的。本质上，MDC数据从web线程中复制到了使用@Async注解的异步线程里中了。想参考原文中的代码，可以前往<a href="https://github.com/moelholm/smallexamples/tree/master/spring43-async-taskdecorator" target="_blank" rel="noopener">github</a>。</p><h2 id="一-代码示例"><a href="#一-代码示例" class="headerlink" title="一. 代码示例"></a>一. 代码示例</h2><p>这个例子基于Spring Boot 2。日志API这里用的是SLF4J和Logback（用了Logger, LoggerFactory和MDC）。</p><p>1 pom.xml</p><pre><code class="xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p>2 application.properties</p><pre><code class="properties">logging.pattern.level: &quot;%X{mdcData}%5p&quot;</code></pre><p>3 MessageRestController</p><pre><code class="java">@RestControllerpublic class MessageRestController {    private final Logger logger = LoggerFactory.getLogger(getClass());    @Autowired    private MessageRepository messageRepository;    @GetMapping    public List&lt;String&gt; list() throws Exception {        logger.info(&quot;RestController in action&quot;);        // 调用异步方法        return messageRepository.findAll().get();    }}</code></pre><p>4 MessageRepository</p><pre><code class="java">@Repositorypublic class MessageRepository {    private final Logger logger = LoggerFactory.getLogger(getClass());    @Async    Future&lt;List&lt;String&gt;&gt; findAll() {        logger.info(&quot;Repository in action&quot;);//        System.out.println(MDC.get(&quot;mdcData&quot;));        return new AsyncResult&lt;&gt;(Arrays.asList(&quot;Hello World&quot;, &quot;Spring Boot is awesome&quot;));    }}</code></pre><p>5 往web线程里设置MDC数据</p><pre><code class="java">@Componentpublic class MdcFilter extends GenericFilterBean {  @Override  public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)      throws IOException, ServletException {    try {      MDC.put(&quot;mdcData&quot;, &quot;[userId:Duke]&quot;);      chain.doFilter(request, response);    } finally {      MDC.clear();    }  }}</code></pre><p>到此，我们可以在web线程里很轻松的拿到正确配置的MDC数据，但是当一个web请求进入了@Async注解的异步方法调用里，我们却不能跟踪它，MDC数据里的ThreadLocal数据不会简单的自动复制过来。</p><h2 id="二-解决方案"><a href="#二-解决方案" class="headerlink" title="二. 解决方案"></a>二. 解决方案</h2><h3 id="1-配置-Async线程池"><a href="#1-配置-Async线程池" class="headerlink" title="1 配置@Async线程池"></a>1 配置<code>@Async</code>线程池</h3><pre><code class="java">@EnableAsync(proxyTargetClass = true)@SpringBootApplicationpublic class AsyncTaskdecoratorApplication extends AsyncConfigurerSupport {    @Override    public Executor getAsyncExecutor() {        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();        executor.setTaskDecorator(new MdcTaskDecorator());        executor.initialize();        return executor;    }    public static void main(String[] args) {        SpringApplication.run(AsyncTaskdecoratorApplication.class, args);    }}</code></pre><p>继承AsyncConfigurerSupport，我们可以自定义线程池，秘密在于executor.setTaskDecorator(new MdcTaskDecorator())，就是这行代码使我们可以自定义TaskDecorator。</p><h3 id="2-实现TaskDecorator"><a href="#2-实现TaskDecorator" class="headerlink" title="2 实现TaskDecorator"></a>2 实现<code>TaskDecorator</code></h3><pre><code class="java">public class MdcTaskDecorator implements TaskDecorator {    @Override    public Runnable decorate(Runnable runnable) {        try {            // Right now: Web thread context !            // Grab the current thread MDC data            Map&lt;String, String&gt; copyOfContextMap = MDC.getCopyOfContextMap();            return () -&gt; {                // Right now: @Async thread context !                // Restore the Web thread context&#39;s MDC data                System.out.println(&quot;------ decorate ------ &quot;);                MDC.setContextMap(copyOfContextMap);                runnable.run();            };        } finally {            MDC.clear();        }    }}</code></pre><p><code>decorate()</code>方法的参数是一个<code>Runnable</code>对象，返回结果也是另一个<code>Runnable</code>对象,这里，只是把原始的<code>Runnable</code>对象包装了一下，首先取得<code>MDC</code>数据，然后把它放到了委托的<code>run</code>方法里.</p><p>到此，MDC的数据就可以在@Async线程里面获取到了。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从web线程里复制MDC数据到异步线程是如此的容易，这里展示的技巧不局限于复制MDC数据，你也可以使用它来复制其他ThreadLocal数据（MDC内部就是使用ThreadLocal），或者你可以使用TaskDecorator做一些其他完全不同的事情：记录日志，度量方法执行的时间，吞掉异常，退出JVM等。</p><p>参考：</p><ol><li><p><a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/scheduling/concurrent/ThreadPoolTaskExecutor.html#setTaskDecorator-org.springframework.core.task.TaskDecorator-" target="_blank" rel="noopener">[set-task-decorator] ThreadPoolTaskExecutor#setTaskDecorator() (Spring’s JavaDoc)</a></p></li><li><p><a href="https://my.oschina.net/dxqr/blog/2981069" target="_blank" rel="noopener">线程池中使用ThreadLocal方案</a></p></li></ol><blockquote><ol><li>使用ThreadLocal，不会在子线程中（包括new Thread和new线程池）获取到.</li><li>使用InheritableThreadLocal，可以在子线程中（包括new Thread和new线程池）获取到，但是如果用的是线程池，一般不会每次使用的时候重新创建，而他的赋值只能在首次创建的时候可以（Thread类的inheritableThreadLocals变量），后面线程池中的线程重复使用时，一开始赋值的那个变量将会一直存在.</li><li>在spring中，一般通过xml或者@Configuration来配置线程池，那么在项目启动的时候，线程池就完成创建了，根本没有机会给你设置变量，所以最佳实践就是，在线程池提交任务的时候（execute和submit方法），把当前线程的threadlocal变量保存起来，重写run方法或者call方法，并且在调用实际的run方法前，保存刚才保存起来的变量，一般也是放到threadlocal里面，这样在实际的run方法里，就可以方便的通过threadlocal获取到了。</li><li>实现原理如上述3所说，这篇翻译的文章中也是该原理，ali提供了一个<a href="https://github.com/whaon/transmittable-thread-local" target="_blank" rel="noopener">transmittable-thread-local</a>，原理也是上面3所讲的。</li><li>值得说明的一下是，也可以参考<a href="https://spring.io/projects/spring-cloud-sleuth" target="_blank" rel="noopener">Spring Cloud Sleuth</a>的实践，Spring Cloud Sleuth为Spring Cloud实施分布式跟踪解决方案.</li></ol></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>便捷的浏览GitHub代码——Chrome插件Octotree</title>
    <link href="/2019/05/24/%E4%BE%BF%E6%8D%B7%E7%9A%84%E6%B5%8F%E8%A7%88GitHub%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94Chrome%E6%8F%92%E4%BB%B6Octotree/"/>
    <url>/2019/05/24/%E4%BE%BF%E6%8D%B7%E7%9A%84%E6%B5%8F%E8%A7%88GitHub%E4%BB%A3%E7%A0%81%E2%80%94%E2%80%94Chrome%E6%8F%92%E4%BB%B6Octotree/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当我们浏览GitHub上的代码的时候，从一个文件转到另一个文件浏览相当麻烦，需要一直退回，然后再顺着目录结构逐个点击才能看到要看的代码内容。当然如果你要更深入的研究代码，git clone下来放到IDE工具里当然是最好了。如果你仅仅就想看一下代码，不想clone下来，Octotree就能很好的帮助你实现你的这个目标</p></blockquote><p>首先你得想办法在你的Chrome浏览器里安装Octotree插件，我已经安装好里，一起来看一下安装后的效果吧！<br><img src="/2019/05/24/便捷的浏览GitHub代码——Chrome插件Octotree/github02.gif" srcset="/img/loading.gif" alt><br>对比一下没有安装插件之前的界面。<br><img src="/2019/05/24/便捷的浏览GitHub代码——Chrome插件Octotree/github01.jpg" srcset="/img/loading.gif" alt><br>可以看到Octotree插件在页面左侧给我们展示了一个文件树结构，我们可以方便的浏览文件。但是该插件并不支持Gitee（码云），对于经常逛码云的小伙伴可以安装<a href="https://gitee.com/inu1255/GitCodeTree" target="_blank" rel="noopener">GitCodeTree</a>，该插件可以在Gitee和GitHub上显示代码树。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome插件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDKMAN管理本地多版本jdk环境</title>
    <link href="/2019/05/17/SDKMAN%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%A4%9A%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83/"/>
    <url>/2019/05/17/SDKMAN%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%A4%9A%E7%89%88%E6%9C%ACjdk%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>SDKMAN可以管理多版本的开发工具环境，可以参考我的上一篇【<a href="/2019/05/13/SDKMAN——软件开发工具管理器/" title="SDKMAN——软件开发工具管理器">SDKMAN——软件开发工具管理器</a>】入门，可能由于oracle的一些原因，发现SDKMAN默认提供的jdk版本没有出现oracle提供的版本了。但是我们可以从oracle官网下载对应的jdk版本，然后利用SDKMAN来管理自己本地安装的jdk版本，从而可以利用SDKMAN方便的切换jdk环境。</p></blockquote><p>首先SDKMAN不能直接安装在Windows上，需要bash环境，我使用的是win10提供的linux子系统来进行演示的，系统版本信息如下：</p><pre><code class="bash">***@DESKTOP-CNSRI37:~/jdk$ lsb_release -aNo LSB modules are available.Distributor ID: UbuntuDescription:    Ubuntu 18.04.2 LTSRelease:        18.04Codename:       bionic</code></pre><h3 id="一-问题"><a href="#一-问题" class="headerlink" title="一 问题"></a>一 问题</h3><p>当我们用命令<code>sdk list java</code>查看可安装的jdk版本时，如下：</p><pre><code>================================================================================                      19.0.0-grl          11.0.2-zulufx     13.ea.20-open       10.0.2-zulu     12.0.1-zulu         10.0.2-open     12.0.1-librca       9.0.7-zulu     12.0.1-sapmchn      9.0.4-open     12.0.1-open         8.0.212-zulu     12.0.1.j9-adpt      8.0.212-amzn     12.0.1.hs-adpt      8.0.212.j9-adpt     11.0.3-sapmchn      8.0.212.hs-adpt     11.0.3-zulu         8.0.212-librca     11.0.3-amzn         8.0.202-zulufx     11.0.3.j9-adpt      7.0.222-zulu     11.0.3.hs-adpt      6.0.119-zulu     11.0.3-librca          1.0.0-rc-16-grl     11.0.2-open           1.0.0-rc-15-grl================================================================================</code></pre><p>可以发现没有oracle提供的版本，但如果你想用oracle提供的版本又想使用SDKMAN进行管理，依然是可以的。SDKMAN提供了这样的操作方法，接下来就看一下具体的操作吧！</p><h3 id="二-操作"><a href="#二-操作" class="headerlink" title="二 操作"></a>二 操作</h3><h4 id="1-从oracle下载jdk"><a href="#1-从oracle下载jdk" class="headerlink" title="1. 从oracle下载jdk"></a>1. 从oracle下载jdk</h4><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">下载地址</a></p><p>我下载的两个版本：<code>jdk-11.0.3_linux-x64_bin.tar.gz</code>， 、<code>jdk-8u211-linux-x64.tar.gz</code></p><p>然后在linux目录解压一下：</p><p><code>sudo tar xvf jdk-8u211-linux-x64.tar.gz</code> , <code>sudo tar xvf jdk-11.0.3_linux-x64_bin.tar.gz</code></p><p>解压后：</p><pre><code class="bash">***@DESKTOP-CNSRI37:/usr/local/jdk$ lsjdk-11.0.3  jdk1.8.0_211</code></pre><h4 id="2-SDKMAN关联本地安装的jdk"><a href="#2-SDKMAN关联本地安装的jdk" class="headerlink" title="2. SDKMAN关联本地安装的jdk"></a>2. SDKMAN关联本地安装的jdk</h4><p>执行命令 <code>sdk install java java8 /usr/local/jdk/jdk1.8.0_211</code></p><p>执行命令<code>sdk list java</code>,查看：</p><pre><code>================================================================================Available Java Versions================================================================================   + java8               11.0.2-open         1.0.0-rc-15-grl     19.0.0-grl          11.0.2-zulufx     + java11     13.ea.20-open       10.0.2-zulu     12.0.1-zulu         10.0.2-open     12.0.1-librca       9.0.7-zulu     12.0.1-sapmchn      9.0.4-open     12.0.1-open         8.0.212-zulu     12.0.1.j9-adpt      8.0.212-amzn     12.0.1.hs-adpt      8.0.212.j9-adpt     11.0.3-sapmchn      8.0.212.hs-adpt     11.0.3-zulu         8.0.212-librca     11.0.3-amzn         8.0.202-zulufx     11.0.3.j9-adpt      7.0.222-zulu     11.0.3.hs-adpt      6.0.119-zulu     11.0.3-librca       1.0.0-rc-16-grl================================================================================+ - local version* - installed&gt; - currently in use================================================================================</code></pre><p>可以发现多了<code>java8</code></p><p>执行命令<code>sdk use java java8</code>，然后选择使用的版本</p><p>执行命令<code>java -version</code>，效果:</p><pre><code class="bash">***@DESKTOP-CNSRI37:/usr/local/jdk$ java -versionjava version &quot;1.8.0_211&quot;Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</code></pre><p>如果没有生效，则执行一下<code>source ~/.bashrc</code>，使配置生效（更新环境变量）；</p><p>同样的操作关联本地的jdk-11.0.3版本。</p><h4 id="3-切换jdk版本"><a href="#3-切换jdk版本" class="headerlink" title="3. 切换jdk版本"></a>3. 切换jdk版本</h4><pre><code class="bash">***@DESKTOP-CNSRI37:/usr/local/jdk$ sdk use java java11Using java version java11 in this shell.***@DESKTOP-CNSRI37:/usr/local/jdk$ java -versionjava version &quot;11.0.3&quot; 2019-04-16 LTSJava(TM) SE Runtime Environment 18.9 (build 11.0.3+12-LTS)Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.3+12-LTS, mixed mode)***@DESKTOP-CNSRI37:/usr/local/jdk$***@DESKTOP-CNSRI37:/usr/local/jdk$***@DESKTOP-CNSRI37:/usr/local/jdk$ sdk use java java8Using java version java8 in this shell.***@DESKTOP-CNSRI37:/usr/local/jdk$ java -versionjava version &quot;1.8.0_211&quot;Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)</code></pre><h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三 总结"></a>三 总结</h3><p>通过上面操作，就可以很方便的切换我们的jdk环境了，除了jdk，其他的一些工具也可以进行类似的操作，如maven,gradle等。</p>]]></content>
    
    
    <categories>
      
      <category>SDKMAN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDKMAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture 组合式异步编程</title>
    <link href="/2019/05/13/CompletableFuture-%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2019/05/13/CompletableFuture-%E7%BB%84%E5%90%88%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>有时候当你想批量调取第三方api获取数据，并将返回的信息聚集起来，如果我们用直接简单的循环调用，这个处理时间长不说，一个调用超时就会阻塞整个逻辑的处理。如果采用异步的方式调用，编程的成本就会增大，比如最终结果的收集，异常的处理等；在java8中，有提供更加简便的编程方式实现这种异步处理。</p></blockquote><p>首先，设置一个简单的场景吧：比如，我们现在有11个经纬度地址，需要获取他们对应的中文名称，下面就是实现的代码：</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests {    private RestTemplate restTemplate = new RestTemplateBuilder()            .messageConverters(new FastJsonHttpMessageConverter())            .build();    // 调用第三方api获取地址名称    private String getAddress(String latitude, String longitude) {        StopWatch sw = new StopWatch();        sw.start();        JSONObject result = restTemplate.getForObject(&quot;http://api.map.baidu.com/geocoder/v2/?location={1},{2}&amp;output=json&amp;pois=0&amp;ak=************************&quot;,                JSONObject.class, latitude, longitude);        sw.stop();        // 记录执行线程以及耗时时间        System.out.println(String.format(&quot;getAddress: %s -&gt; 耗时: %s&quot;, Thread.currentThread(), sw.getTotalTimeMillis()));        if (result.getInteger(&quot;status&quot;) == 0) {            return result.getJSONObject(&quot;result&quot;).getString(&quot;formatted_address&quot;);        }        return null;    }    @Test    public void test() {        String[] cities = {        &quot;31.2363429624,121.4803295328&quot;,        &quot;39.9110666857,116.4136103013&quot;,        &quot;30.2799186759,120.1617445782&quot;,        &quot;31.8880209204,117.3066537271&quot;,        &quot;25.6122215609,100.2742019952&quot;,        &quot;26.8624428068,100.2335674911&quot;,        &quot;27.6958640000,111.7206640000&quot;,        &quot;31.2093160000,112.4105620000&quot;,        &quot;39.1731490000,117.2202970000&quot;,        &quot;34.5113900000,101.5563070000&quot;,        &quot;30.5984670000,114.3115860000&quot;        };        List&lt;Long&gt; times = new ArrayList&lt;&gt;();        // 调用20次，计算调用11个经纬度耗时时间        IntStream.rangeClosed(1, 20)                .forEach(i -&gt; {                    StopWatch sw = new StopWatch();                    sw.start();                    // 调用实现的方法，更改不同的方法，统计时间                    List&lt;String&gt; r = test1(cities);                    System.out.println(r);                    sw.stop();                    times.add(sw.getTotalTimeMillis());                });        // 耗时统计        LongSummaryStatistics summaryStatistics = times.stream().mapToLong(Long::longValue).summaryStatistics();        System.out.println(times);        System.out.println(&quot;平均耗时: &quot; + summaryStatistics);    }    // 方法一 普通循环调用    private List&lt;String&gt; test1(String[] locations) {        return Arrays.stream(locations)                .filter(city -&gt; city.split(&quot;,&quot;).length == 2)                .map(city -&gt; {                    String[] v = city.split(&quot;,&quot;);                    return getAddress(v[0], v[1]);                })                .collect(Collectors.toList());    }    // java8 Stream并行调用    private List&lt;String&gt; test2(String[] locations) {        return Arrays.stream(locations).parallel()                .filter(city -&gt; city.split(&quot;,&quot;).length == 2)                .map(city -&gt; {                    String[] v = city.split(&quot;,&quot;);                    return getAddress(v[0], v[1]);                })                .collect(Collectors.toList());    }    // java8 CompletableFuture    private List&lt;String&gt; test3(String[] locations) {        List&lt;CompletableFuture&lt;String&gt;&gt; collect = Arrays.stream(locations)                .filter(city -&gt; city.split(&quot;,&quot;).length == 2)                .map(city -&gt; CompletableFuture.supplyAsync(() -&gt; {                    String[] v = city.split(&quot;,&quot;);                    return getAddress(v[0], v[1]);                }))                .collect(Collectors.toList());        return collect.stream()                .map(CompletableFuture::join)                .collect(Collectors.toList());    }}</code></pre><p>这里，我简单的每个方法调用20次，统计一下时间，进行一下对比：</p><p><strong>方法一</strong></p><p>执行<code>test1()</code>时，控制台输出如下：</p><pre><code>[662, 564, 645, 552, 577, 562, 534, 1101, 549, 567, 546, 544, 545, 548, 557, 551, 609, 527, 562, 531][null, 北京市东城区正义路2号-10号楼-403号, 浙江省杭州市拱墅区莫干山路6, 安徽省合肥市瑶海区众兴路, 云南省大理白族自治州大理市第一大道, 云南省丽江市古城区玉雪大道149, 湖南省娄底市涟源市人民东路, 湖北省荆门市钟祥市, null, null, 湖北省武汉市江岸区沿江大道188号][396]平均耗时: LongSummaryStatistics{count=20, sum=11833, min=527, average=591.650000, max=1101}</code></pre><p>11个经纬度，平均耗时591.650000毫秒。</p><p><strong>方法二</strong></p><p>执行<code>test2()</code>时，控制台输出如下：</p><pre><code>...getAddress: Thread[ForkJoinPool.commonPool-worker-3,5,main] -&gt; 耗时: 32getAddress: Thread[ForkJoinPool.commonPool-worker-1,5,main] -&gt; 耗时: 29getAddress: Thread[ForkJoinPool.commonPool-worker-3,5,main] -&gt; 耗时: 25getAddress: Thread[ForkJoinPool.commonPool-worker-1,5,main] -&gt; 耗时: 25getAddress: Thread[ForkJoinPool.commonPool-worker-3,5,main] -&gt; 耗时: 25getAddress: Thread[ForkJoinPool.commonPool-worker-2,5,main] -&gt; 耗时: 233[277, 252, 143, 116, 160, 164, 119, 125, 125, 121, 125, 127, 121, 132, 128, 128, 118, 124, 113, 236][null, 北京市东城区正义路2号-10号楼-403号, 浙江省杭州市拱墅区莫干山路6, 安徽省合肥市瑶海区众兴路, 云南省大理白族自治州大理市第一大道, 云南省丽江市古城区玉雪大道149, 湖南省娄底市涟源市人民东路, 湖北省荆门市钟祥市, null, null, 湖北省武汉市江岸区沿江大道188号][396]平均耗时: LongSummaryStatistics{count=20, sum=2954, min=113, average=147.700000, max=277}</code></pre><p>可见，多个线程在执行调用，平均耗时147.700000毫秒。</p><p><strong>方法三</strong></p><p>执行<code>test3()</code>时，控制台输出如下：</p><pre><code>...getAddress: Thread[ForkJoinPool.commonPool-worker-1,5,main] -&gt; 耗时: 157getAddress: Thread[ForkJoinPool.commonPool-worker-2,5,main] -&gt; 耗时: 46getAddress: Thread[main,5,main] -&gt; 耗时: 53getAddress: Thread[ForkJoinPool.commonPool-worker-3,5,main] -&gt; 耗时: 51getAddress: Thread[ForkJoinPool.commonPool-worker-1,5,main] -&gt; 耗时: 51getAddress: Thread[ForkJoinPool.commonPool-worker-2,5,main] -&gt; 耗时: 56[280, 157, 164, 166, 209, 194, 164, 263, 233, 203, 158, 154, 162, 152, 167, 154, 149, 149, 155, 159][null, 北京市东城区正义路2号-10号楼-403号, 浙江省杭州市拱墅区莫干山路6, 安徽省合肥市瑶海区众兴路, 云南省大理白族自治州大理市第一大道, 云南省丽江市古城区玉雪大道149, 湖南省娄底市涟源市人民东路, 湖北省荆门市钟祥市, null, null, 湖北省武汉市江岸区沿江大道188号][396]平均耗时: LongSummaryStatistics{count=20, sum=3592, min=149, average=179.600000, max=280}</code></pre><p>同样的多个线程在异步执行，平均耗时179.600000毫秒；</p><p>其实从效果上还看(这里运行次数较少，运行时有时候方法二好有时候方法三好)，方法二和方法三它们看起来不相伯仲，究其原因都一样:它们内部采用的是同样的通用线程池，默认都使用固定数目的线程，具体线程数取决于<code>Runtime.getRuntime().availableProcessors()</code>的返回值。尽然这样，方法二更简洁易懂，为什么还需要<code>CompletableFuture</code>呢？然而，<code>CompletableFuture</code>具有一定的优势，因为它允许你对执行器(Executor)进行配置，尤其是线程池的大小，让它以更适合应用需求的方式进行配置，满足程序的要求，而这是并行流API无法提供的。</p><p><code>CompletableFuture</code>中4个异步执行任务静态方法：</p><pre><code class="java">public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier) {        return asyncSupplyStage(asyncPool, supplier);    }public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier,Executor executor) {    return asyncSupplyStage(screenExecutor(executor), supplier);}public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) {    return asyncRunStage(asyncPool, runnable);}public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor) {    return asyncRunStage(screenExecutor(executor), runnable);}</code></pre><p>参考：《java8实战》</p>]]></content>
    
    
    
    <tags>
      
      <tag>java8</tag>
      
      <tag>CompletableFuture</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>更好的调试 Java Stream</title>
    <link href="/2019/05/13/%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%B0%83%E8%AF%95-Java-Stream/"/>
    <url>/2019/05/13/%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%B0%83%E8%AF%95-Java-Stream/</url>
    
    <content type="html"><![CDATA[<blockquote><p>java8里新增的Stream API非常强大，能够开发出更加简洁易懂的代码，但是如果出现问题，往往也没那么好去调试。这里主要介绍使用idea的Stream debugger方法。</p></blockquote><p>举个简单的例子</p><pre><code class="java">List&lt;Integer&gt; collect = Stream.of(0, 1, 2, 3, 4, 10, 11)                .filter(item -&gt; item % 2 == 0)                .map(item -&gt; item * 100)                .collect(Collectors.toList());</code></pre><p>这段代码想做的就是找出一组数据中的偶数，并把找出来的偶数扩大100倍。</p><p>如果我们想了解stream的流水线操作，每个操作后的结果是什么，我们像其他代码一样去用ide工具debug也不好使。在此我们可以想到用<code>peek()</code>去打印出每个操作后的结果，如下：</p><pre><code class="java">  List&lt;Integer&gt; collect = Stream.of(0, 1, 2, 3, 4, 10, 11)                .filter(item -&gt; item % 2 == 0)                .peek(System.out::println)                .map(item -&gt; item * 100)                .peek(System.out::println)                .collect(Collectors.toList());</code></pre><p>输出结果：</p><pre><code>0022004400101000</code></pre><p>这样虽然能够达到目的，但是IntelliJ’s debugger 给我们更加形象化的表示：</p><p><img src="/2019/05/13/更好的调试-Java-Stream/Xnip2018-12-14_21-47-44.jpg" srcset="/img/loading.gif" alt></p><p>怎么操作呢。</p><p><strong>第1步 想调用<code>stream debugger</code>的话，首先要在<code>Stream</code>定义处设置断点</strong></p><p><strong>第2步 以<code>debug</code>模式运行代码</strong></p><p><strong>第3步 当到达断点时，可以按指定的按钮来调用 Stream debugger，如下：</strong></p><p><img src="/2019/05/13/更好的调试-Java-Stream/Xnip2018-12-14_21-54-17.jpg" srcset="/img/loading.gif" alt></p><p>OK，大功告成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IntelliJ IDEA</tag>
      
      <tag>java8</tag>
      
      <tag>java stream</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SDKMAN——软件开发工具管理器</title>
    <link href="/2019/05/13/SDKMAN%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AE%A1%E7%90%86%E5%99%A8/"/>
    <url>/2019/05/13/SDKMAN%E2%80%94%E2%80%94%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这个工具是在大多数基于Unix的系统上管理多个软件开发工具包的并行版本的工具。它提供了一个方便的命令行接口(CLI)和API，用于安装、切换、删除和列出候选对象，它的前身是Groovy环境管理器GVM，其灵感来自Ruby社区广泛使用的非常有用的RVM和rbenv工具。</p></blockquote><h2 id="一-特点"><a href="#一-特点" class="headerlink" title="一. 特点"></a><strong>一. 特点</strong></h2><p><img src="/2019/05/13/SDKMAN——软件开发工具管理器/WX20181020-004138@2x.png" srcset="/img/loading.gif" alt></p><h2 id="二-安装"><a href="#二-安装" class="headerlink" title="二. 安装"></a><strong>二. 安装</strong></h2><ol><li><strong>针对类unix平台</strong></li></ol><pre><code class="shell"># first$ curl -s &quot;https://get.sdkman.io&quot; | bash# next$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;# lastly ensure that installation succeeded$ sdk version</code></pre><p>如果安装成功，则终端显示：</p><pre><code class="shell">SDKMAN 5.7.3+337</code></pre><ol start="2"><li><strong>windows安装</strong></li></ol><p>请注意，由于SDKMAN是在bash中编写的，因此它需要一个bash环境。SDKMAN不能直接安装在Windows上，需要Cygwin或MSYS+MinGW。</p><p><a href="https://sdkman.io/install" target="_blank" rel="noopener">参考官网说明</a></p><h2 id="三-卸载"><a href="#三-卸载" class="headerlink" title="三. 卸载"></a><strong>三. 卸载</strong></h2><p>使用命令：</p><pre><code class="shell">tar zcvf ~/sdkman-backup_$(date +%F-%kh%M).tar.gz -C ~/ .sdkman$ rm -rf ~/.sdkman</code></pre><h2 id="四-使用"><a href="#四-使用" class="headerlink" title="四. 使用"></a><strong>四. 使用</strong></h2><blockquote><p>支持安装的开发工具包</p></blockquote><pre><code>Available SDKsAntAsciidoctorJBpipeCeylonCRaSHCUBA CLICXFGaidenGlideGradleGrailsGroovyGroovyServInfrastructorJavaJBakeKotlinkscriptLazybonesLeiningenMavenMicronautsbtScalaSparkSpring BootSshoogrVert.xVisualVM</code></pre><ol><li><strong>安装</strong></li></ol><ul><li>安装最近稳定版本，例如安装<code>Java JDK</code></li></ul><pre><code class="shell">$ sdk install java</code></pre><ul><li>安装特定版本</li></ul><pre><code class="shell">$ sdk install java 10.0.2-oracle</code></pre><p>版本可以通过 <code>sdk list java</code>获取</p><pre><code class="shell">$ sdk list java===============================================================Available Java Versions===============================================================     12.ea.15-open     11.0.1-open     10.0.2-zulu     10.0.2-open     10.0.2-oracle     9.0.7-zulu     9.0.4-open     8.0.191-oracle     8.0.181-zulu     7.0.181-zulu     1.0.0-rc7-graal===============================================================+ - local version * - installed&gt; - currently in use</code></pre><p><strong>注：命令<code>sdk list</code>可以列出所有可以安装sdk</strong></p><ul><li>安装本地版本</li></ul><pre><code class="shell"># 官网栗子$ sdk install groovy 3.0.0-SNAPSHOT /path/to/groovy-3.0.0-SNAPSHOT</code></pre><p>例如，我本地已经安装了Java8版本，我可以这样操作(mac系统)：</p><pre><code class="shell">$ sdk install java java8 /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home</code></pre><pre><code class="shell"># 查看安装结果sdk list java=================================================================Available Java Versions=================================================================   + java8     12.ea.15-open     11.0.1-open     10.0.2-zulu     10.0.2-open &gt; * 10.0.2-oracle     9.0.7-zulu     9.0.4-open     8.0.191-oracle     8.0.181-zulu     7.0.181-zulu     1.0.0-rc7-graal=================================================================+ - local version* - installed&gt; - currently in use</code></pre><pre><code class="shell"># 查看版本$ java -versionjava version &quot;10.0.2&quot; 2018-07-17Java(TM) SE Runtime Environment 18.3 (build 10.0.2+13)Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.2+13, mixed mode)$ sdk use java java8Using java version java8 in this shell.$ java -versionjava version &quot;1.8.0_181&quot;Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</code></pre><ol start="2"><li><strong>移除安装的版本</strong></li></ol><pre><code class="shell">sdk uninstall java 10.0.2-oracle</code></pre><ol start="3"><li><strong>选择版本</strong></li></ol><pre><code class="shell"># 重要的是要意识到这只会切换当前shell的候选版本。要使此更改永久性，请使用默认命令。sdk use java 8.0.191-oracle</code></pre><ol start="4"><li><strong>默认版本</strong></li></ol><pre><code class="shell"># 这将确保所有后续shell都将从8.0.191-oracle版本开始使用。sdk default java 8.0.191-oracle</code></pre><ol start="5"><li><strong>More操作参考<a href="https://sdkman.io/" target="_blank" rel="noopener">官网</a></strong></li></ol><h2 id="五-原理"><a href="#五-原理" class="headerlink" title="五. 原理"></a>五. <strong>原理</strong></h2><p>查看sdkman安装目录结构(默认在<code>~/.sdkman</code>下)</p><p><img src="/2019/05/13/SDKMAN——软件开发工具管理器/Xnip2018-10-20_12-15-25.jpg" srcset="/img/loading.gif" alt></p><p>sdkman采用一系列脚本来注册sdk相关命令，在系统中通过sdkman安装某candidate，它的安装主要依赖sdkman-install.sh（看上图）来实现的，依次下载了candidate的zip压缩包及安装脚本，再通过脚本来执行安装流程，本质上是与正常的unix安装流程是一样的。下载的组件分别至于archive及temp目录下，安装的组件在candidates目录下，可以看到默认的current为指向某一版本的软链接</p><p><img src="/2019/05/13/SDKMAN——软件开发工具管理器/WX20181020-123559@2x.png" srcset="/img/loading.gif" alt></p><pre><code class="shell">drwxr-xr-x  11 ishiv  staff   352B 10 20 12:33 10.0.2-oraclelrwxr-xr-x   1 ishiv  staff    42B 10 20 03:34 current -&gt; /Users/ishiv/.sdkman/candidates/java/java8lrwxr-xr-x   1 ishiv  staff    64B 10 20 03:19 java8 -&gt; /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home</code></pre><p>查看<code></code>.bash_profile<code>文件，</code>cat ~/.bash_profile `，可以看到追加了一些脚本</p><pre><code class="shell">export PATH=$PATH:/usr/local/mysql/binexport PATH=$PATH:/Users/ishiv/software/apache-maven-3.5.4/bin#下面这一段是由于安装sdkman后自动追加的#THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!!export SDKMAN_DIR=&quot;/Users/ishiv/.sdkman&quot;[[ -s &quot;/Users/ishiv/.sdkman/bin/sdkman-init.sh&quot; ]] &amp;&amp; source &quot;/Users/ishiv/.sdkman/bin/sdkman-init.sh&quot;</code></pre><p>每次启动shell环境，都会预先加载 .bash_profile 等文件中的环境，这样就可以直接使用~/.sdkman中的sdk环境了。</p>]]></content>
    
    
    <categories>
      
      <category>SDKMAN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SDKMAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cloud Toolkit——高效开发、测试、诊断并部署应用插件</title>
    <link href="/2019/05/08/Cloud-Toolkit%E2%80%94%E2%80%94%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E8%AF%8A%E6%96%AD%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8F%92%E4%BB%B6/"/>
    <url>/2019/05/08/Cloud-Toolkit%E2%80%94%E2%80%94%E9%AB%98%E6%95%88%E5%BC%80%E5%8F%91%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E8%AF%8A%E6%96%AD%E5%B9%B6%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Alibaba Cloud Toolkit是一个面向 IntelliJ IDEA、Eclipse 和 Maven 平台的免费插件，旨在帮助开发者在本地开发平台（IDE）中更便捷的使用阿里云，从而高效地开发、测试、诊断并部署应用。 帮助开发者将本地应用程序一键部署到线下自有 VM，或阿里云 ECS、EDAS、Kubernetes 中去；并支持快速 SSH 登录到机器，高效执行终端命令和文件上传等</p></blockquote><p>该插件有<code>IntelliJ版</code>、<code>Eclipse版</code> 和 <code>Maven版</code></p><p><img src="/2019/05/08/Cloud-Toolkit——高效开发、测试、诊断并部署应用插件/./cloud toolkit01.jpg" srcset="/img/loading.gif" alt="cloud toolkit01"></p><p>下面介绍几个好用的功能。首先我们在 <code>IntelliJ</code> 插件里搜索 <code>cloud toolkit</code>，如下，然后安装即可。</p><p><img src="/2019/05/08/Cloud-Toolkit——高效开发、测试、诊断并部署应用插件/./cloud toolkit05.jpg" srcset="/img/loading.gif" alt="cloud toolkit05"></p><h2 id="内置终端-Terminal"><a href="#内置终端-Terminal" class="headerlink" title="内置终端 Terminal"></a>内置终端 Terminal</h2><blockquote><p>IDE 内，开发者可以直接通过内置的终端 Terminal，快速登录远程服务器；<strong>不仅仅用于阿里云服务器 ECS</strong>，所有支持标准 SSH 协议的机器，都可以</p></blockquote><p><img src="/2019/05/08/Cloud-Toolkit——高效开发、测试、诊断并部署应用插件/./cloud toolkit02.gif" srcset="/img/loading.gif" alt="cloud toolkit02"></p><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><blockquote><p>Cloud Toolkit 帮助开发者在 IDE 内，一键将<strong>本地</strong>或者<strong>远程 URL </strong>文件上传到服务器指定目录下去，无需在各种 FTP、SCP 工具之间频繁切换。更为重要的是，文件上传完毕后，还支持<strong>命令执行</strong>，比如：文件解压缩、程序启动等</p></blockquote><p><img src="/2019/05/08/Cloud-Toolkit——高效开发、测试、诊断并部署应用插件/./cloud toolkit03.gif" srcset="/img/loading.gif" alt="cloud toolkit03"></p><h2 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h2><blockquote><p>Cloud Toolkit 帮助开发者将本地应用程序一键部署到线下自有 VM，或阿里云 ECS、EDAS 和 Kubernetes 中去。</p></blockquote><p>例如：部署到 ECS</p><p><img src="/2019/05/08/Cloud-Toolkit——高效开发、测试、诊断并部署应用插件/./cloud toolkit04.gif" srcset="/img/loading.gif" alt="cloud toolkit04"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>更多详细的操作，可以访问<a href="https://www.aliyun.com/product/cloudtoolkit" target="_blank" rel="noopener">官方网站</a>，里面还有对应的视频操作可以参照。</p>]]></content>
    
    
    
    <tags>
      
      <tag>IntelliJ IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GraphQL简单前后端Demo</title>
    <link href="/2019/05/07/graphql%E7%AE%80%E5%8D%95%E5%89%8D%E5%90%8E%E7%AB%AFdemo/"/>
    <url>/2019/05/07/graphql%E7%AE%80%E5%8D%95%E5%89%8D%E5%90%8E%E7%AB%AFdemo/</url>
    
    <content type="html"><![CDATA[<blockquote><p>之前组内就有说过<code>graphql</code>,在做影像字段配置的时候，当时就提过使用<code>graphql</code>来实现，但是综合考虑，并没有采用。所以趁着有空，自己写一个<code>demo</code>体验以下!</p></blockquote><h2 id="一-什么是graphql"><a href="#一-什么是graphql" class="headerlink" title="一 什么是graphql"></a>一 什么是graphql</h2><p>借用官网的话——一种用于 API 的查询语言。</p><blockquote><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p></blockquote><p>一个 GraphQL 服务是通过定义类型和类型上的字段来创建的，然后给每个类型上的每个字段<strong>提供解析函数</strong>。为每一个字段都提供一个解析函数，听起来工作量挺大，其实已经有一些很好的工具会帮我们自动解析简单字段类型！</p><p>接下来直接上例子~</p><h2 id="二-后台服务-springboot-graghql"><a href="#二-后台服务-springboot-graghql" class="headerlink" title="二 后台服务 springboot + graghql"></a>二 后台服务 springboot + graghql</h2><p><strong>1 pom.xml</strong></p><pre><code class="xml">&lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.0.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;            &lt;artifactId&gt;h2&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- graphql相关 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;            &lt;artifactId&gt;graphql-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;5.0.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- GraphiQL tool for schema introspection and query debugging           能提供一个/graphiql页面，提供查询，方面测试        --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;            &lt;artifactId&gt;graphiql-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;5.0.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- 能够从GraphQL的模式定义*.graphqls文件构建出对应的Java的POJO类型对象.会将类路径中任何名为*.graphqls的文件用于提供模式定义 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;            &lt;artifactId&gt;graphql-java-tools&lt;/artifactId&gt;            &lt;version&gt;5.2.4&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p><strong>2 demoapi.graphqls</strong></p><p>在类路径下新建demoapi.graphqls文件，提供schema定义，graphql-java-tools会负责解析。</p><pre><code>type Query {    school(id: ID): School    student(id: ID): Student}type School {    id: Int    name: String    ranking: Int}type Student {    id: Int    name: String    age: Int    classId: Int}</code></pre><p><strong>3 获取数据</strong></p><blockquote><p>需要实现GraphQLQueryResolver接口</p></blockquote><pre><code class="java">@Componentpublic class Query implements GraphQLQueryResolver {    @Autowired    private SchoolMapper schoolMapper;    @Autowired    private StudentMapper studentMapper;    public School getSchool(Integer id) {        return schoolMapper.getById(id);    }    public Student student(Integer id) {        return studentMapper.getById(id);    }}</code></pre><p>因为将<code>graphql-spring-boot-starter</code>作为依赖项添加到引导应用程序，并且应用程序中有GraphQLSchema bean，则可以在/graphql上访问servlet。</p><p><strong>4 启动程序</strong></p><p>启动后台，访问<code>http://localhost:8080/graphiql</code>，查询接口：</p><p><img src="/2019/05/07/graphql简单前后端demo/./graphql01.jpg" srcset="/img/loading.gif" alt="graphql01"></p><p><img src="/2019/05/07/graphql简单前后端demo/./graphql02.jpg" srcset="/img/loading.gif" alt="graphql02"></p><p>如图，后台接口不做更改，前端可以根据自己需求获取自己需要的数据，而且返回的数据结构跟你的请求结构相似！<strong>这个页面工具对能询到哪些字段信息有很好的提示功能。</strong></p><p>当然，对于构建后台api有多种方式，如：</p><pre><code class="java">@Bean    GraphQLSchema schema() {        return GraphQLSchema.newSchema()                .query(GraphQLObjectType.newObject()                        .name(&quot;query&quot;)                        .field(field -&gt; field                                .name(&quot;test&quot;)                                .type(Scalars.GraphQLString)                                .dataFetcher(environment -&gt; &quot;response&quot;)                        )                        .build())                .build();    }</code></pre><p>这种方式，需要我们针对每一个字段提供一个解析函数，如上面的<code>dataFetcher</code>.这对于一些字段很多，返回字段名称很java对象的字段名称一致的，这样难免很乏所。对于这种情况，第一种方式——利用<code>graphql-java-tools</code>还是更加便捷一些。</p><p>好了，后端接口就写到这块，前端我们应该发送请求过来了？</p><p>首先我们可以看一下，上面的请求页面——<code>Graphiql</code>是怎么发送请求的，打开chrome的调试工具：</p><p><img src="/2019/05/07/graphql简单前后端demo/./graphql03.jpg" srcset="/img/loading.gif" alt="graphql03"></p><p>发现，是post请求，我们的请求参数如上图所示。所以发到后台的数据格式有一定的要求。比较庆幸的是，有一些很优秀的前端工具帮我做了这些，比如：<code>apollo-client</code>, <code>graphql.js</code>等，这里我使用<code>graphql.js</code>，因为它更轻量级。</p><h2 id="三-web页面"><a href="#三-web页面" class="headerlink" title="三 web页面"></a>三 web页面</h2><p>前端搭建一个简单的vue项目：</p><p>安装<code>graphql.js</code>:</p><pre><code class="bash">npm install graphql.js --save</code></pre><p>为了方便在vue中使用，做下列操作：</p><p>1 创建<code>GraphQLProvider.js</code></p><pre><code class="js">import graphql from &#39;graphql.js&#39;export default {  install (Vue, url, options) {    Vue.mixin({      created () {        this._graph = graphql(url, options)      }    })    Object.defineProperty(Vue.prototype, &#39;$graph&#39;, {      get () {        return this._graph      }    })  }}</code></pre><p>2 在<code>main.js</code>中引入</p><pre><code class="js">import GraphQLProvider from &#39;./util/GraphQLProvider&#39;Vue.use(GraphQLProvider, &#39;http://localhost:8080/graphql&#39;, {  // method: &#39;POST&#39;, 默认就是post  alwaysAutodeclare: true,  asJSON: true,  debug: true,  headers: {    // headers...  }})</code></pre><p>然后就可以在页面使用<code>this.$graph</code>去使用了。实际操作：</p><pre><code class="js">export default {  name: &#39;test&#39;,  data () {    return {      msg: &#39;&#39;    }  },  mounted () {    this.test()  },  methods: {    test () {      let param = `        school(id: 1) {          name          id        }      `      this.$graph.query.run(param).then(response =&gt; {        console.log(response)        this.msg = response      })    }  }}</code></pre><p>ok，刷新页面：</p><p><img src="/2019/05/07/graphql简单前后端demo/./graphql04.jpg" srcset="/img/loading.gif" alt="graphql04"></p><p>到此，我们可以改变变量param请求参数，就可以获取自己想要的信息了。这里这是一个简单的演示，关于更多的信息，可以参考下面。</p><p><a href="https://github.com/justsme/graphql-simple-demo.git" target="_blank" rel="noopener">代码示例GitHub</a><br><strong>更多信息</strong></p><ol><li><a href="http://graphql.cn/" target="_blank" rel="noopener">Graphql官网</a></li><li><a href="https://github.com/f/graphql.js" target="_blank" rel="noopener">graphql.js</a></li><li><a href="https://github.com/apollographql/apollo-client" target="_blank" rel="noopener">apollo-client</a></li><li><a href="https://github.com/graphql-java-kickstart/graphql-spring-boot" target="_blank" rel="noopener">graphql-spring-boot</a></li><li><a href="https://github.com/graphql-java/graphql-java" target="_blank" rel="noopener">graphql-java</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>GraphQL</tag>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jackson Annotations(二)</title>
    <link href="/2019/05/05/Jackson%20Annotations(%E4%BA%8C)/"/>
    <url>/2019/05/05/Jackson%20Annotations(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>接着上一篇【<a href="/2019/04/27/Jackson Annotations(一)/" title="Jackson Annotations(一)">Jackson Annotations(一)</a>】,接着再介绍Jackson Property Inclusion Annotations和一些更加普遍的注解。为了方便，这里面很多直接用了public属性。  </p></blockquote><h2 id="Jackson-Property-Inclusion-Annotations"><a href="#Jackson-Property-Inclusion-Annotations" class="headerlink" title="Jackson Property Inclusion Annotations"></a>Jackson Property Inclusion Annotations</h2><h3 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a>@JsonIgnoreProperties</h3><p><code>@JsonIgnoreProperties</code> 标识<code>jackson</code>序列化或反序列化将忽略的属性。</p><pre><code class="java">@JsonIgnoreProperties({ &quot;id&quot; })public class BeanWithIgnore {    public int id;    public String name;    public BeanWithIgnore() {    }    public BeanWithIgnore(final int id, final String name) {        this.id = id;        this.name = name;    }    @Override    public String toString() {        return &quot;BeanWithIgnore{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><p>序列化</p><pre><code class="java">@Test    public void whenSerializingUsingJsonIgnoreProperties() throws JsonProcessingException {        BeanWithIgnore bean = new BeanWithIgnore(1, &quot;My bean&quot;);        String result = new ObjectMapper().writeValueAsString(bean);        System.out.println(result);        assertThat(result, containsString(&quot;My bean&quot;));        assertThat(result, not(containsString(&quot;id&quot;)));    }</code></pre><p>输出结果：</p><pre><code>{&quot;name&quot;:&quot;My bean&quot;}</code></pre><p>反序列化</p><pre><code class="java">@Test    public void whenSerializingUsingJsonIgnoreProperties1() throws IOException {        String json = &quot;{\&quot;id\&quot;: 1, \&quot;name\&quot;:\&quot;My bean\&quot;}&quot;;        BeanWithIgnore beanWithIgnore = new ObjectMapper().readerFor(BeanWithIgnore.class).readValue(json);        System.out.println(beanWithIgnore);    }</code></pre><pre><code>BeanWithIgnore{id=0, name=&#39;null&#39;}</code></pre><h3 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h3><p>标明的field, getter/setter method or Creator parameter等在序列化或者发序列化时将被忽略。<br>将上面例子的实体修改一下用<code>@JsonIgnore</code>，测试代码不变，可以得到相同的结果。</p><pre><code class="java">//@JsonIgnoreProperties({ &quot;id&quot; })public class BeanWithIgnore {    @JsonIgnore    public int id;    public String name;    public BeanWithIgnore() {    }    public BeanWithIgnore(final int id, final String name) {        this.id = id;        this.name = name;    }    @Override    public String toString() {        return &quot;BeanWithIgnore{&quot; +                &quot;id=&quot; + id +                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +                &#39;}&#39;;    }}</code></pre><h3 id="JsonIgnoreType"><a href="#JsonIgnoreType" class="headerlink" title="@JsonIgnoreType"></a>@JsonIgnoreType</h3><p><code>@JsonIgnoreType</code> 标识<code>jackson</code>序列化或反序列化将忽略某些类型的属性。</p><pre><code class="java">public class Teacher {    public int id;    public Name name;    public Teacher() {    }    public Teacher(final int id, final Name name) {        this.id = id;        this.name = name;    }    @JsonIgnoreType    public static class Name {        public String firstName;        public String lastName;        public Name() {        }        public Name(final String firstName, final String lastName) {            this.firstName = firstName;            this.lastName = lastName;        }    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonIgnoreType()            throws JsonProcessingException, ParseException {        Teacher.Name name = new Teacher.Name(&quot;John&quot;, &quot;Doe&quot;);        Teacher teacher = new Teacher(1, name);        String result = new ObjectMapper().writeValueAsString(teacher);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{&quot;id&quot;:1}</code></pre><h3 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a>@JsonInclude</h3><p>使用<code>@JsonInclude</code>注解可以控制field, method or constructor parameter的<strong>序列化</strong>。例如下面，我们排出序列化时的<code>null</code>值。</p><pre><code class="java">@JsonInclude(JsonInclude.Include.NON_NULL)public class IncludeBean {    public int id;    public String name;    public IncludeBean() {    }    public IncludeBean(final int id, final String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonInclude() throws JsonProcessingException {        IncludeBean bean = new IncludeBean(1, null);        String result = new ObjectMapper().writeValueAsString(bean);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{&quot;id&quot;:1}</code></pre><p>可以看到<code>name</code>属性没有被序列化.</p><h3 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h3><p>修改属性自动检测<br>默认的Jackson属性检测规则将找到：</p><ul><li>所有的<code>public</code>类型的属性</li><li>所有的<code>public</code>类型的<code>get</code>方法</li><li>所有的<code>set</code>方法（无论方法的可见性）</li></ul><p>如果默认规则不能满足需求，可以用<code>@JsonAutoDetect</code>注解来改变。</p><ol><li>如果想检测所有属性，可以<pre><code class="java">@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.ANY)public class POJOWithFields {private int value;}</code></pre></li><li>如果想禁止检测所有属性<pre><code class="java">@JsonAutoDetect(fieldVisibility=JsonAutoDetect.Visibility.NONE)public class POJOWithNoFields {// 该属性将不被包含，除非有getValue()方法public int value;}</code></pre></li></ol><h2 id="处理多态类型"><a href="#处理多态类型" class="headerlink" title="处理多态类型"></a>处理多态类型</h2><h3 id="JsonTypeInfo-JsonSubTypes-JsonTypeName"><a href="#JsonTypeInfo-JsonSubTypes-JsonTypeName" class="headerlink" title="@JsonTypeInfo,@JsonSubTypes ,@JsonTypeName"></a>@JsonTypeInfo,<em>@JsonSubTypes</em> ,@JsonTypeName</h3><p>如果需要读取和写入具有多个可能子类型的对象的值（即表现出多态性的对象），则可能需要启用包含类型信息。这是必需的，以便Jackson在反序列化时读取正确的对象类型（将JSON读入对象）。这可以通过<code>@JsonTypeInfo</code>在“基类”上添加注释来完成，更详细的信息，可以参考文章下面的链接。</p><pre><code class="java">public class Zoo {    public Animal animal;    public Zoo() {    }    public Zoo(final Animal animal) {        this.animal = animal;    }    @JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;type&quot;)    @JsonSubTypes({ @JsonSubTypes.Type(value = Dog.class, name = &quot;dog&quot;), @JsonSubTypes.Type(value = Cat.class, name = &quot;cat&quot;) })    public static class Animal {        public String name;        public Animal() {        }        public Animal(final String name) {            this.name = name;        }    }    public static class Dog extends Animal {        public double barkVolume;        public Dog() {        }        public Dog(final String name) {            this.name = name;        }    }    public static class Cat extends Animal {        boolean likesCream;        public int lives;        public Cat() {        }        public Cat(final String name) {            this.name = name;        }    }}</code></pre><p>序列化测试：</p><pre><code class="java">@Test    public void whenSerializingPolymorphic() throws JsonProcessingException {        Zoo.Dog dog = new Zoo.Dog(&quot;lacy&quot;);        Zoo zoo = new Zoo(dog);        String result = new ObjectMapper().writeValueAsString(zoo);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;animal&quot;:{        &quot;type&quot;:&quot;dog&quot;,        &quot;name&quot;:&quot;lacy&quot;,        &quot;barkVolume&quot;:0    }}</code></pre><p>反序列化测试：</p><pre><code class="java">@Test    public void whenDeserializingPolymorphic() throws IOException {        String json = &quot;{\&quot;animal\&quot;:{\&quot;name\&quot;:\&quot;lacy\&quot;,\&quot;type\&quot;:\&quot;cat\&quot;}}&quot;;        Zoo zoo = new ObjectMapper().readerFor(Zoo.class)                .readValue(json);        assertEquals(&quot;lacy&quot;, zoo.animal.name);        assertEquals(Zoo.Cat.class, zoo.animal.getClass());    }</code></pre><p>该测试会success.</p><h2 id="更普遍使用的注解"><a href="#更普遍使用的注解" class="headerlink" title="更普遍使用的注解"></a>更普遍使用的注解</h2><h3 id="JsonProperty"><a href="#JsonProperty" class="headerlink" title="@JsonProperty"></a>@JsonProperty</h3><p>作用在字段或方法上，用来对属性的序列化/反序列化，可以用来提供对属性名称重命名，处理非标准的<code>Getter</code>和<code>Setter</code>。</p><pre><code class="java">public class JsonPropertyBean {    public int id;    private String name;    public JsonPropertyBean() {    }    public JsonPropertyBean(final int id, final String name) {        this.id = id;        this.name = name;    }    @JsonProperty(&quot;name&quot;)//    @JsonSetter(&quot;name&quot;)    public void setTheName(final String name) {        this.name = name;    }    @JsonProperty(&quot;name&quot;)//    @JsonGetter(&quot;name&quot;)    public String getTheName() {        return name;    }}</code></pre><pre><code class="java">@Test    public void whenUsingJsonProperty() throws IOException {        JsonPropertyBean bean = new JsonPropertyBean(1, &quot;My bean&quot;);        String result = new ObjectMapper().writeValueAsString(bean);        // {&quot;id&quot;:1,&quot;name&quot;:&quot;My bean&quot;}        System.out.println(result);        JsonPropertyBean resultBean = new ObjectMapper().readerFor(JsonPropertyBean.class)                .readValue(result);        assertEquals(&quot;My bean&quot;, resultBean.getTheName());    }</code></pre><h3 id="JsonFormat"><a href="#JsonFormat" class="headerlink" title="@JsonFormat"></a>@JsonFormat</h3><p>当序列化时指定<code>Date/Time</code>的格式化。</p><pre><code class="java">public class DateFormatBean {    @JsonFormat(pattern=&quot;yyyy-MM-dd hh:mm:ss&quot;, timezone=&quot;GMT+8&quot;)    public Date birth;    public DateFormatBean() {}    public DateFormatBean(Date birth) {        this.birth = birth;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonFormat() throws JsonProcessingException {        DateFormatBean bean = new DateFormatBean(new Date());        String result = new ObjectMapper().writeValueAsString(bean);        System.out.println(result);    }</code></pre><p>输出结果（如果不加该注解，默认输出毫秒时间戳），</p><pre><code class="js">{&quot;birth&quot;:&quot;2019-04-28 11:01:04&quot;}</code></pre><h3 id="JsonUnwrapped"><a href="#JsonUnwrapped" class="headerlink" title="@JsonUnwrapped"></a>@JsonUnwrapped</h3><p><code>@JsonUnwrapped</code>定义了序列化/反序列化时应解包/展平的值。看下面的例子：</p><pre><code class="java">public class UnwrappedUser {    public int id;    @JsonUnwrapped    public Name name;    public UnwrappedUser() {    }    public UnwrappedUser(final int id, final Name name) {        this.id = id;        this.name = name;    }    public static class Name {        public String firstName;        public String lastName;        public Name() {        }        public Name(final String firstName, final String lastName) {            this.firstName = firstName;            this.lastName = lastName;        }    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonUnwrapped() throws JsonProcessingException, ParseException {        UnwrappedUser.Name name = new UnwrappedUser.Name(&quot;John&quot;, &quot;Doe&quot;);        UnwrappedUser user = new UnwrappedUser(1, name);        String result = new ObjectMapper().writeValueAsString(user);        System.out.println(result);        assertThat(result, containsString(&quot;John&quot;));        assertThat(result, not(containsString(&quot;name&quot;)));    }</code></pre><p>输出结果，静态内部类的字段和其他字段一起平铺展开：</p><pre><code class="js">{    &quot;id&quot;:1,    &quot;firstName&quot;:&quot;John&quot;,    &quot;lastName&quot;:&quot;Doe&quot;}</code></pre><h3 id="JsonView"><a href="#JsonView" class="headerlink" title="@JsonView"></a>@JsonView</h3><p>@JsonView可以用来指定序列化/反序列化包含的属性，下面，看一下具体的例子。</p><pre><code class="java">public class Views {    public static class Public {    }    public static class Internal extends Public {    }}</code></pre><pre><code class="java">public class Item {    @JsonView(Views.Public.class)    public int id;    @JsonView(Views.Public.class)    public String itemName;    @JsonView(Views.Internal.class)    public String ownerName;    public Item() {        super();    }    public Item(int id, String itemName, String ownerName) {        this.id = id;        this.itemName = itemName;        this.ownerName = ownerName;    }    public int getId() {        return id;    }    public String getItemName() {        return itemName;    }    public String getOwnerName() {        return ownerName;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonView_thenCorrect() throws JsonProcessingException {        Item item = new Item(2, &quot;book&quot;, &quot;John&quot;);        String result = new ObjectMapper().writerWithView(Views.Public.class)                .writeValueAsString(item);        System.out.println(result);        String result1 = new ObjectMapper().writerWithView(Views.Internal.class)                .writeValueAsString(item);        System.out.println(result1);    }</code></pre><p>​    result打印结果：</p><pre><code class="js">{    &quot;id&quot;:2,    &quot;itemName&quot;:&quot;book&quot;}</code></pre><p>result1j打印结果：</p><pre><code class="js">{    &quot;id&quot;:2,    &quot;itemName&quot;:&quot;book&quot;,    &quot;ownerName&quot;:&quot;John&quot;}</code></pre><h3 id="JsonManagedReference，-JsonBackReference"><a href="#JsonManagedReference，-JsonBackReference" class="headerlink" title="@JsonManagedReference，@ JsonBackReference"></a>@JsonManagedReference，@ JsonBackReference</h3><p>@JsonManagedReference和@JsonBackReference注释可以处理父/子关系和解决循环问题。这两个注解在使用的时候，@JsonBackReference标注的属性不会被序列化，从而解决循环引用无法序列化问题。</p><pre><code class="java">public class ItemWithRef {    public int id;    public String itemName;    @JsonManagedReference    public UserWithRef owner;    public ItemWithRef() {        super();    }    public ItemWithRef(int id, String itemName, UserWithRef owner) {        this.id = id;        this.itemName = itemName;        this.owner = owner;    }}public class UserWithRef {    public int id;    public String name;    @JsonBackReference    public ItemWithRef item;    public UserWithRef() {        super();    }    public UserWithRef(int id, String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJacksonReferenceAnnotation() throws JsonProcessingException {        UserWithRef user = new UserWithRef(1, &quot;John&quot;);        ItemWithRef item = new ItemWithRef(2, &quot;book&quot;, user);        user.item = item;        String result = new ObjectMapper().writeValueAsString(item);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;id&quot;:2,    &quot;itemName&quot;:&quot;book&quot;,    &quot;owner&quot;:{        &quot;id&quot;:1,        &quot;name&quot;:&quot;John&quot;    }}</code></pre><h3 id="JsonIdentityInfo"><a href="#JsonIdentityInfo" class="headerlink" title="@JsonIdentityInfo"></a>@JsonIdentityInfo</h3><p>使用这个注解也可以用来解决循环引用问题，不像前两个注解那用序列化时忽略某个属性。看下面的例子：</p><pre><code class="java">@JsonIdentityInfo(generator = ObjectIdGenerators.PropertyGenerator.class, property = &quot;id&quot;)public class ItemWithIdentity {    public int id;    public String itemName;    public UserWithIdentity owner;    public ItemWithIdentity() {        super();    }    public ItemWithIdentity(final int id, final String itemName, final UserWithIdentity owner) {        this.id = id;        this.itemName = itemName;        this.owner = owner;    }}@JsonIdentityInfo(generator = ObjectIdGenerators.UUIDGenerator.class)public class UserWithIdentity {    public int id;    public String name;    public ItemWithIdentity item;    public UserWithIdentity() {        super();    }    public UserWithIdentity(int id, String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonIdentityInfo() throws JsonProcessingException {        UserWithIdentity user = new UserWithIdentity(1, &quot;John&quot;);        ItemWithIdentity item = new ItemWithIdentity(2, &quot;book&quot;, user);        user.item = item;        String result = new ObjectMapper().writeValueAsString(item);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;id&quot;:2,    &quot;itemName&quot;:&quot;book&quot;,    &quot;owner&quot;:{        &quot;@id&quot;:&quot;82d8a603-a4e0-4dd2-b3e5-c2207529c59a&quot;,        &quot;id&quot;:1,        &quot;name&quot;:&quot;John&quot;,        &quot;item&quot;:2    }}</code></pre><p><a href="https://github.com/FasterXML/jackson-annotations" target="_blank" rel="noopener">参考:github</a><br><a href="https://www.baeldung.com/jackson-annotations" target="_blank" rel="noopener">参考:Jackson Annotation Examples</a></p>]]></content>
    
    
    <categories>
      
      <category>jackson</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Jackson Annotations(一)</title>
    <link href="/2019/04/27/Jackson%20Annotations(%E4%B8%80)/"/>
    <url>/2019/04/27/Jackson%20Annotations(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这周看了一篇<code>Jackson JSON Tutorial</code>，觉得很不错，自己也写代码运行学习了一下，做个记录。那个网站是个英文网站，文章结尾我附了地址，想看原版英文的同学可以自己进去学习。下面的内容就是记录其中的一些内容。我所用的Jackson版本为2.9.8。内容有点多，分两次记录。这篇主要介绍一些序列化注解和反序列化注解，了解他们的作用。下一篇再介绍Jackson Property Inclusion Annotations和一些更加普遍的注解。</p></blockquote><p>我是直接建了一个<code>springboot</code>项目，直接在里面写的测试。项目的pom.xml.</p><pre><code class="xml">&lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;groupId&gt;com.justme&lt;/groupId&gt;    &lt;artifactId&gt;jackson-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;jackson-demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;            &lt;version&gt;2.0.1&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;            &lt;artifactId&gt;h2&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><p><code>jackson</code>的版本：</p><pre><code class="bash">[INFO] +- org.springframework.boot:spring-boot-starter-web:jar:2.1.4.RELEASE:compile[INFO] |  +- org.springframework.boot:spring-boot-starter-json:jar:2.1.4.RELEASE:compile[INFO] |  |  +- com.fasterxml.jackson.core:jackson-databind:jar:2.9.8:compile[INFO] |  |  |  +- com.fasterxml.jackson.core:jackson-annotations:jar:2.9.0:compile[INFO] |  |  |  \- com.fasterxml.jackson.core:jackson-core:jar:2.9.8:compile[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jdk8:jar:2.9.8:compile[INFO] |  |  +- com.fasterxml.jackson.datatype:jackson-datatype-jsr310:jar:2.9.8:compile[INFO] |  |  \- com.fasterxml.jackson.module:jackson-module-parameter-names:jar:2.9.8:compile</code></pre><h2 id="一-Jackson-Serialization-Annotations"><a href="#一-Jackson-Serialization-Annotations" class="headerlink" title="一. Jackson Serialization Annotations"></a>一. Jackson Serialization Annotations</h2><p>首先我们看一下序列化注解。</p><h3 id="1-1-JsonAnyGetter"><a href="#1-1-JsonAnyGetter" class="headerlink" title="1.1 @JsonAnyGetter"></a>1.1 <code>@JsonAnyGetter</code></h3><p>该注解允许我们灵活的将<code>Map</code>的字段作为标准的属性，如下例子：</p><pre><code class="java">@Getter@Setterpublic class Student {    private String name;    private Map&lt;String, String&gt; properties;    public Student() {        properties = new HashMap&lt;String, String&gt;();    }    @JsonAnyGetter    public Map&lt;String, String&gt; getProperties() {        return properties;    }    public void add(final String key, final String value) {        properties.put(key, value);    }}</code></pre><pre><code class="java">@Test    public void testSerializingUsingJsonAnyGetter() throws JsonProcessingException {        Student student = new Student();        student.setName(&quot;jack&quot;);        student.add(&quot;attr1&quot;, &quot;val1&quot;);        student.add(&quot;attr2&quot;, &quot;val2&quot;);        String result = new ObjectMapper().writeValueAsString(student);        System.out.println(result);    }</code></pre><p>输出结果(经过格式化)：</p><pre><code class="js">{    &quot;name&quot;:&quot;jack&quot;,    &quot;attr2&quot;:&quot;val2&quot;,    &quot;attr1&quot;:&quot;val1&quot;}</code></pre><p>如果不加<code>@JsonAnySetter</code>,结果为：</p><pre><code class="js">{    &quot;name&quot;:&quot;jack&quot;,    &quot;properties&quot;:{        &quot;attr2&quot;:&quot;val2&quot;,        &quot;attr1&quot;:&quot;val1&quot;    }}</code></pre><h3 id="1-2-JsonGetter"><a href="#1-2-JsonGetter" class="headerlink" title="1.2 @JsonGetter"></a>1.2 <code>@JsonGetter</code></h3><p><code>@JsonGetter</code>可替代<code>@JsonProperty</code>标记一个方法作为<code>Getter</code>方法，如下：</p><pre><code class="java">public class MyBean {    public int id;    private String name;    @JsonGetter(&quot;name&quot;)    public String getTheName() {        return name;    }    public MyBean(final int id, final String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonGetter()            throws IOException {        MyBean bean = new MyBean(1, &quot;My bean&quot;);        String result = new ObjectMapper().writeValueAsString(bean);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;id&quot;:1,    &quot;name&quot;:&quot;My bean&quot;}</code></pre><h3 id="1-3-JsonPropertyOrder"><a href="#1-3-JsonPropertyOrder" class="headerlink" title="1.3 @JsonPropertyOrder"></a>1.3 <code>@JsonPropertyOrder</code></h3><p>该注解可以用来指定序列化时属性的顺序，如下：</p><pre><code class="java">@JsonPropertyOrder({ &quot;name&quot;, &quot;id&quot; })public class MyBean {    public int id;    private String name;    @JsonGetter(&quot;name&quot;)    public String getTheName() {        return name;    }    public MyBean(final int id, final String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonGetter()            throws IOException {        MyBean bean = new MyBean(1, &quot;My bean&quot;);        String result = new ObjectMapper().writeValueAsString(bean);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;name&quot;:&quot;My bean&quot;,    &quot;id&quot;:1}</code></pre><h3 id="1-4-JsonRawValue"><a href="#1-4-JsonRawValue" class="headerlink" title="1.4 @JsonRawValue"></a>1.4 <code>@JsonRawValue</code></h3><p>该注解可以让jackson准确的序列化一个属性。添加该注解的属性或者方法应按原样包含属性的文本字符串值进行序列化，而不引用字符。这对于在JSON中插入已序列化的值或将javascript函数定义从服务器传递到javascript client非常有用。如下，对比一下添加和不添加该注解序列化的情况：</p><pre><code class="java">public class RawBean {    public String name;    @JsonRawValue    public String json;    public RawBean(final String name, final String json) {        this.name = name;        this.json = json;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonRawValue()            throws JsonProcessingException {        RawBean bean = new RawBean(&quot;My bean&quot;, &quot;{\&quot;attr\&quot;:false}&quot;);        String result = new ObjectMapper().writeValueAsString(bean);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;name&quot;:&quot;My bean&quot;,    &quot;json&quot;:{        &quot;attr&quot;:false    }}</code></pre><p>不加注解的情况：</p><pre><code class="js">{&quot;name&quot;:&quot;My bean&quot;,&quot;json&quot;:&quot;{\&quot;attr\&quot;:false}&quot;}</code></pre><h3 id="1-5-JsonValue"><a href="#1-5-JsonValue" class="headerlink" title="1.5 @JsonValue"></a>1.5 <code>@JsonValue</code></h3><p>用以替代缺省的方法，由该方法来完成json的字符输出。例如，修改上面的<code>RawBean</code>,</p><pre><code class="java">public class RawBean {    public String name;    @JsonRawValue    public String json;    public RawBean(final String name, final String json) {        this.name = name;        this.json = json;    }    @JsonValue    public String json() {        return &quot;JsonValue&quot;;    }}</code></pre><p>输出结果为：</p><pre><code>&quot;JsonValue&quot;</code></pre><h3 id="1-6-JsonRootName"><a href="#1-6-JsonRootName" class="headerlink" title="1.6 @JsonRootName"></a>1.6 <code>@JsonRootName</code></h3><p>直接对比一下效果：</p><pre><code class="java">@JsonRootName(value = &quot;user&quot;)public class UserWithRoot {    public int id;    public String name;    public UserWithRoot(final int id, final String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonRootName()            throws JsonProcessingException {        final UserWithRoot user = new UserWithRoot(1, &quot;John&quot;);        final ObjectMapper mapper = new ObjectMapper();        // 这个需要添加，否则@JsonRootName(value = &quot;user&quot;)不会起作用        mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);        final String result = mapper.writeValueAsString(user);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{    &quot;user&quot;:{        &quot;id&quot;:1,        &quot;name&quot;:&quot;John&quot;    }}</code></pre><p>不添加该注解,且注释掉 // mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);，则输出结果</p><pre><code class="js">{    &quot;id&quot;:1,    &quot;name&quot;:&quot;John&quot;}</code></pre><h3 id="1-7-JsonSerialize"><a href="#1-7-JsonSerialize" class="headerlink" title="1.7 @JsonSerialize"></a>1.7 <code>@JsonSerialize</code></h3><p>自定义序列化。</p><pre><code class="java">@Getter@Setterpublic class Student {    private String name;    @JsonSerialize(using = CustomDateSerializer.class)    private Date birth;}</code></pre><pre><code class="java">@Test    public void whenSerializingUsingJsonSerialize() throws JsonProcessingException, ParseException {        Student student = new Student();        student.setName(&quot;shi&quot;);        student.setBirth(new Date());        String result = new ObjectMapper().writeValueAsString(student);        System.out.println(result);    }</code></pre><p>输出结果：</p><pre><code class="js">{&quot;name&quot;:&quot;shi&quot;,&quot;birth&quot;:&quot;2019-04-27 04:02:06&quot;}</code></pre><p>不添加该注解：</p><pre><code class="js">{&quot;name&quot;:&quot;shi&quot;,&quot;birth&quot;:1556351977873}</code></pre><h2 id="二-Jackson-Deserialization-Annotations"><a href="#二-Jackson-Deserialization-Annotations" class="headerlink" title="二. Jackson Deserialization Annotations"></a>二. Jackson Deserialization Annotations</h2><h3 id="2-1-JsonCreator"><a href="#2-1-JsonCreator" class="headerlink" title="2.1 @JsonCreator"></a>2.1 <code>@JsonCreator</code></h3><p>我们可以使用@JsonCreator注释来调整反序列化中使用的构造函数/工厂,当我们需要反序列化一些与我们需要获得的目标实体不完全匹配的JSON时，它非常有用。当反序列化时，@JsonCreator注解的构造函数被会调用，如果没有@JsonCreator注解，则默认调用java类的无参构造函数，此时，如果java类中只有有参构造函数，而无默认的无参构造函数，在反序列化时会抛出异常，所以，当我们不使用@JsonCreator指定反序列化的构造函数，而又在java类中重载了构造函数时，一定要记得编写类的无参构造函数。</p><pre><code class="java">@Getter@Setterpublic class User {    private String name;    private Integer age;    @JsonCreator    public User(@JsonProperty(&quot;username&quot;) String name) {        System.out.println(&quot;------&gt;&quot; + name);        this.name = name;    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><pre><code class="java"> @Test    public void whenDeserializingUsingJsonCreator() throws IOException {        final String json = &quot;{\&quot;age\&quot;:19,\&quot;username\&quot;:\&quot;json creater\&quot;}&quot;;        User user = new ObjectMapper().readerFor(User.class)                .readValue(json);        System.out.println(user);    }</code></pre><p>输出结果：</p><pre><code>------&gt;json creater=nullUser{name=&#39;json creater&#39;, age=19}</code></pre><p>从上面可以看出，当json字符串里的key和实体属性不完全匹配时，这种方案很有效。而且可以发现，利用这个注解我们也不必为实体添加无参构造器。</p><p>我们稍微改一下实体类，也可以这么用：</p><pre><code class="java">@Getter@Setterpublic class User {    private String name;    private Integer age;//    @JsonCreator//    public User(@JsonProperty(&quot;username&quot;) String name) {//        System.out.println(&quot;------&gt;&quot; + name);//        this.name = name;//    }    @JsonCreator    public User(Map map) {        System.out.println(&quot;------&gt;&quot; + map);    }    @Override    public String toString() {        return &quot;User{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, age=&quot; + age +                &#39;}&#39;;    }}</code></pre><p>输出结果：</p><pre><code>------&gt;{age=19, username=json creater}User{name=&#39;null&#39;, age=null}</code></pre><h3 id="2-2-JacksonInject"><a href="#2-2-JacksonInject" class="headerlink" title="2.2 @JacksonInject"></a>2.2 <code>@JacksonInject</code></h3><p> 表示属性将从注入中获取其值，而不是从JSON数据中获取.</p><pre><code class="java">public class BeanWithInject {    @JacksonInject    public int id;    public String name;    public BeanWithInject() {    }    public BeanWithInject(final int id, final String name) {        this.id = id;        this.name = name;    }}</code></pre><pre><code class="java"> @Test    public void whenDeserializingUsingJsonInject() throws IOException {        String json = &quot;{\&quot;name\&quot;:\&quot;My bean\&quot;}&quot;;        InjectableValues inject = new InjectableValues.Std().addValue(int.class, 1);        BeanWithInject bean = new ObjectMapper().reader(inject)                .forType(BeanWithInject.class)                .readValue(json);        assertEquals(&quot;My bean&quot;, bean.name);        assertEquals(1, bean.id);    }</code></pre><p>上面的Test会success。</p><h3 id="2-3-JsonAnySetter"><a href="#2-3-JsonAnySetter" class="headerlink" title="2.3 @JsonAnySetter"></a>2.3 <code>@JsonAnySetter</code></h3><p><code>@JsonAnySetter</code>允许我们灵活地使用Map作为标准属性。在反序列化时，JSON中的属性将简单地添加到地图中.</p><pre><code class="java">@Getter@Setterpublic class Student {    private String name;    private Map&lt;String, String&gt; properties;    public Student() {        properties = new HashMap&lt;String, String&gt;();    }    @JsonAnyGetter    public Map&lt;String, String&gt; getProperties() {        return properties;    }    @JsonAnySetter    public void add(final String key, final String value) {        properties.put(key, value);    }    @Override    public String toString() {        return &quot;Student{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, properties=&quot; + properties +                &#39;}&#39;;    }}</code></pre><pre><code class="java"> @Test    public void whenDeserializingUsingJsonAnySetter() throws IOException {        String json = &quot;{\&quot;name\&quot;:\&quot;My bean\&quot;,\&quot;attr2\&quot;:\&quot;val2\&quot;,\&quot;attr1\&quot;:\&quot;val1\&quot;}&quot;;        Student student = new ObjectMapper().readerFor(Student.class)                .readValue(json);        System.out.println(student);    }</code></pre><p>输出结果：</p><pre><code class="java">Student{name=&#39;My bean&#39;, properties={attr2=val2, attr1=val1}}</code></pre><h3 id="2-4-JsonSetter"><a href="#2-4-JsonSetter" class="headerlink" title="2.4 @JsonSetter"></a>2.4 <code>@JsonSetter</code></h3><p><code>@JsonSetter</code> 将该方法标记为setter方法。当我们需要读取一些JSON数据但目标实体类与该数据不完全匹配时，这非常有用，因此我们需要调整该过程以使其适合.在下面的示例中，我们将指定方法<code>setTheName()</code>作为MyBean实体中name属性的setter ：</p><pre><code class="java">public class MyBean {    public int id;    private String name;    @JsonSetter(&quot;name&quot;)    public void setTheName(String name) {        this.name = name;    }}</code></pre><pre><code class="java">@Testpublic void whenDeserializingUsingJsonSetter()  throws IOException {    String json = &quot;{\&quot;id\&quot;:1,\&quot;name\&quot;:\&quot;My bean\&quot;}&quot;;    MyBean bean = new ObjectMapper()      .readerFor(MyBean.class)      .readValue(json);    assertEquals(&quot;My bean&quot;, bean.getTheName());}</code></pre><p>上面的Test会success。</p><h3 id="2-5-JsonDeserialize"><a href="#2-5-JsonDeserialize" class="headerlink" title="2.5 @JsonDeserialize"></a>2.5 <code>@JsonDeserialize</code></h3><p>自定义反序列化器。</p><pre><code class="java">@Getter@Setterpublic class Student {    private String name;    @JsonDeserialize(using = CustomDateDeserializer.class)    private Date birth;    @Override    public String toString() {        return &quot;Student{&quot; +                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, birth=&quot; + birth +                &#39;}&#39;;    }}</code></pre><pre><code class="java"> @Test    public void whenDeserializingUsingJsonDeserialize_thenCorrect()            throws IOException {        String json = &quot;{\&quot;name\&quot;: \&quot;shi\&quot;, \&quot;birth\&quot;: \&quot;2000-01-01 02:30:00\&quot;}&quot;;        Student student = new ObjectMapper()                .readerFor(Student.class)                .readValue(json);        System.out.println(student);    }</code></pre><p>输出结果：</p><pre><code>Student{name=&#39;shi&#39;, birth=Sat Jan 01 02:30:00 CST 2000}</code></pre><h3 id="2-6-JsonAlias"><a href="#2-6-JsonAlias" class="headerlink" title="2.6 @JsonAlias"></a>2.6 <code>@JsonAlias</code></h3><p><code>@JsonAlias</code>定义反序列化过程为属性的一个或多个的替代名称.</p><pre><code class="java">@Datapublic class AliasBean {    @JsonAlias({ &quot;fName&quot;, &quot;f_name&quot; })    private String firstName;    private String lastName;}</code></pre><pre><code class="java">@Test    public void whenDeserializingUsingJsonAlias_thenCorrect() throws IOException {        String json = &quot;{\&quot;fName\&quot;: \&quot;John\&quot;, \&quot;lastName\&quot;: \&quot;Green\&quot;}&quot;;        AliasBean aliasBean = new ObjectMapper().readerFor(AliasBean.class).readValue(json);        System.out.println(aliasBean);        assertThat(aliasBean.getFirstName(), is(&quot;John&quot;));    }</code></pre><p>输出结果：</p><pre><code>AliasBean(firstName=John, lastName=Green)</code></pre><p><a href="https://www.baeldung.com/jackson-annotations" target="_blank" rel="noopener">参考:Jackson Annotation Examples</a></p>]]></content>
    
    
    <categories>
      
      <category>jackson</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JOOQ——The easiest way to write SQL in Java</title>
    <link href="/2019/04/27/JOOQ%E2%80%94%E2%80%94The%20easiest%20way%20to%20write%20SQL%20in%20Java/"/>
    <url>/2019/04/27/JOOQ%E2%80%94%E2%80%94The%20easiest%20way%20to%20write%20SQL%20in%20Java/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近在看<a href="https://docs.spring.io/spring-boot/docs/2.0.5.RELEASE/reference/htmlsingle/#_jooq_sql_dialect" target="_blank" rel="noopener">springboot官方文档</a>的时候，在数据库连接章节看到了JOOQ，于是了解了一下。</p></blockquote><h2 id="一-什么是JOOQ"><a href="#一-什么是JOOQ" class="headerlink" title="一. 什么是JOOQ"></a>一. 什么是JOOQ</h2><p>JOOQ（Java Object Oriented Querying ）是Data Geekery的一个流行产品，它从数据库中生成Java代码，并允许您通过它的fluent API构建类型安全的SQL查询。JOOQ 既吸取了传统ORM操作数据的简单性和安全性，又保留了原生sql的灵活性，它更像是介于 ORMS和JDBC的中间层。</p><p>官网上说使用jOOQ DSL, SQL看起来几乎是由Java本地支持的，那么就直接看那看看例子吧：</p><p>sql:</p><pre><code class="sql">SELECT AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, COUNT(*)FROM AUTHORJOIN BOOK ON AUTHOR.ID = BOOK.AUTHOR_IDWHERE BOOK.LANGUAGE = &#39;DE&#39;AND BOOK.PUBLISHED &gt; DATE &#39;2008-01-01&#39;GROUP BY AUTHOR.FIRST_NAME, AUTHOR.LAST_NAMEHAVING COUNT(*) &gt; 5ORDER BY AUTHOR.LAST_NAME ASC NULLS FIRSTLIMIT 2OFFSET 1</code></pre><p>对应java代码：</p><pre><code class="java">create.select(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME, count())      .from(AUTHOR)      .join(BOOK).on(AUTHOR.ID.equal(BOOK.AUTHOR_ID))      .where(BOOK.LANGUAGE.eq(&quot;DE&quot;))      .and(BOOK.PUBLISHED.gt(date(&quot;2008-01-01&quot;)))      .groupBy(AUTHOR.FIRST_NAME, AUTHOR.LAST_NAME)      .having(count().gt(5))      .orderBy(AUTHOR.LAST_NAME.asc().nullsFirst())      .limit(2)      .offset(1)</code></pre><p>可以看出java代码很接近sql的风格，所以写起来还是很流畅。</p><h2 id="二-springboot-jOOQ"><a href="#二-springboot-jOOQ" class="headerlink" title="二. springboot + jOOQ"></a>二. springboot + jOOQ</h2><h3 id="1-pom-xml"><a href="#1-pom-xml" class="headerlink" title="1. pom.xml"></a>1. pom.xml</h3><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;cn.justme&lt;/groupId&gt;    &lt;artifactId&gt;jooq-demo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;name&gt;jooq-demo&lt;/name&gt;    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.0.6.RELEASE&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;java.version&gt;1.8&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!--h2的 browser-based console 自动配置需要这个jar--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-jooq&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.h2database&lt;/groupId&gt;            &lt;artifactId&gt;h2&lt;/artifactId&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;            &lt;!--jooq代码生成 --&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.jooq&lt;/groupId&gt;                &lt;artifactId&gt;jooq-codegen-maven&lt;/artifactId&gt;                &lt;executions&gt;                    &lt;execution&gt;                        &lt;goals&gt;                            &lt;goal&gt;generate&lt;/goal&gt;                        &lt;/goals&gt;                    &lt;/execution&gt;                &lt;/executions&gt;                &lt;dependencies&gt;                    &lt;dependency&gt;                        &lt;groupId&gt;com.h2database&lt;/groupId&gt;                        &lt;artifactId&gt;h2&lt;/artifactId&gt;                        &lt;version&gt;${h2.version}&lt;/version&gt;                    &lt;/dependency&gt;                &lt;/dependencies&gt;                &lt;configuration&gt;                    &lt;jdbc&gt;                        &lt;driver&gt;org.h2.Driver&lt;/driver&gt;                        &lt;url&gt;jdbc:h2:~/test&lt;/url&gt;                        &lt;user&gt;sa&lt;/user&gt;                        &lt;password&gt;&lt;/password&gt;                    &lt;/jdbc&gt;                    &lt;generator&gt;                        &lt;name&gt;org.jooq.util.DefaultGenerator&lt;/name&gt;                        &lt;database&gt;                            &lt;name&gt;org.jooq.util.h2.H2Database&lt;/name&gt;                            &lt;includes&gt;.*&lt;/includes&gt;                            &lt;excludes /&gt;                            &lt;inputSchema&gt;PUBLIC&lt;/inputSchema&gt;                        &lt;/database&gt;                        &lt;target&gt;                            &lt;packageName&gt;justme.cn.jooqdemo.domain&lt;/packageName&gt;                            &lt;directory&gt;${basedir}/src/main/java&lt;/directory&gt;                        &lt;/target&gt;                        &lt;generate&gt;                            &lt;pojos&gt;true&lt;/pojos&gt;                            &lt;!--&lt;records&gt;false&lt;/records&gt;--&gt;                        &lt;/generate&gt;                    &lt;/generator&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;</code></pre><h3 id="2-准备sql"><a href="#2-准备sql" class="headerlink" title="2. 准备sql"></a>2. 准备sql</h3><p>schema.sql</p><pre><code class="sql">CREATE TABLE author (  id              NUMBER(7)     NOT NULL PRIMARY KEY,  first_name      VARCHAR2(50),  last_name       VARCHAR2(50)  NOT NULL,  date_of_birth   DATE,  year_of_birth   NUMBER(7),  distinguished   NUMBER(1));</code></pre><p>data.sql</p><pre><code class="sql">INSERT INTO author VALUES (1, &#39;Greg&#39;, &#39;Turnquest&#39;, &#39;1804-09-17&#39;, 1804, 1);INSERT INTO author VALUES (2, &#39;Craig&#39;, &#39;Walls&#39;, &#39;1804-09-18&#39;, 1804, 1);</code></pre><p>这两个放src/main/resources目录下，应用启动后会自动执行。</p><h3 id="3-生成代码"><a href="#3-生成代码" class="headerlink" title="3. 生成代码"></a>3. 生成代码</h3><p>如图</p><p><img src="/2019/04/27/JOOQ——The easiest way to write SQL in Java/./JOOQ1.jpg" srcset="/img/loading.gif" alt></p><h3 id="4-编写代码"><a href="#4-编写代码" class="headerlink" title="4. 编写代码"></a>4. 编写代码</h3><p>AuthorService.java</p><pre><code class="java">@Servicepublic class AuthorService {    @Autowired    private DSLContext create;    public void getById(Integer id) {        Result&lt;Record&gt; fetch = create.select().from(AUTHOR).where(AUTHOR.ID.eq(id)).fetch();        System.out.println(&quot;输出结果&quot;);        System.out.println(fetch);//        List&lt;Author&gt; authors = create.select().from(AUTHOR).where(AUTHOR.ID.eq(id)).fetchInto(Author.class);//        System.out.println(authors);    }    public void insert(Author author) {        create.insertInto(AUTHOR)                .set(AUTHOR.ID, author.getId())                .set(AUTHOR.FIRST_NAME, author.getFirstName())                .set(AUTHOR.LAST_NAME, author.getLastName())                .execute();        Result&lt;Record&gt; fetch = create.select().from(AUTHOR).fetch();        System.out.println(&quot;输出结果&quot;);        System.out.println(fetch);    }    public void insert2(Author author) {        AuthorRecord authorRecord = create.newRecord(AUTHOR, author);        authorRecord.store();        create.insertInto(AUTHOR).set(authorRecord).execute();        Result&lt;Record&gt; fetch = create.select().from(AUTHOR).fetch();        System.out.println(&quot;输出结果&quot;);        System.out.println(fetch);    }}</code></pre><p>测试</p><pre><code class="java">package cn.justme.jooqdemo;import cn.justme.jooqdemo.domain.tables.pojos.Author;import cn.justme.jooqdemo.service.AuthorService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;import java.io.IOException;@RunWith(SpringRunner.class)@SpringBootTestpublic class JooqDemoApplicationTests {    @Autowired    private AuthorService authorService;    @Test    public void contextLoads() {    }    @Test    public void testGetById() {        authorService.getById(1);    }    /*     * 输出结果     * +----+----------+---------+-------------+-------------+-------------+     * |  ID|FIRST_NAME|LAST_NAME|DATE_OF_BIRTH|YEAR_OF_BIRTH|DISTINGUISHED|     * +----+----------+---------+-------------+-------------+-------------+     * |   1|Greg      |Turnquest|1804-09-17   |         1804|            1|     * +----+----------+---------+-------------+-------------+-------------+     */    @Test    public void testInsert() {        Author author = new Author();        author.setId(3);        author.setFirstName(&quot;shi&quot;);        author.setLastName(&quot;wei&quot;);        authorService.insert(author);    }    @Test    public void testInsert2() throws IOException {        Author author = new Author();        author.setId(3);        author.setFirstName(&quot;shi&quot;);        author.setLastName(&quot;wei&quot;);        authorService.insert2(author);    }    /*     * 输出结果     * +----+----------+---------+-------------+-------------+-------------+     * |  ID|FIRST_NAME|LAST_NAME|DATE_OF_BIRTH|YEAR_OF_BIRTH|DISTINGUISHED|     * +----+----------+---------+-------------+-------------+-------------+     * |   1|Greg      |Turnquest|1804-09-17   |         1804|            1|     * |   2|Craig     |Walls    |1804-09-18   |         1804|            1|     * |   3|shi       |wei      |{null}       |       {null}|       {null}|     * +----+----------+---------+-------------+-------------+-------------+     */}</code></pre><h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>初步体验，写java代写起来确实有种写sql的感觉，上手还是挺容易的，后面再继续看看文档，有什么小项目，感觉可以尝试尝试。 jooq还支持主流的RDMS和更多的特性，如self-joins，union，存储过程，复杂的子查询等等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JOOQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud OpenFeign支持POJO提作为GET参数映射</title>
    <link href="/2019/04/23/Spring-Cloud-OpenFeign%E6%94%AF%E6%8C%81POJO%E6%8F%90%E4%BD%9C%E4%B8%BAGET%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84/"/>
    <url>/2019/04/23/Spring-Cloud-OpenFeign%E6%94%AF%E6%8C%81POJO%E6%8F%90%E4%BD%9C%E4%B8%BAGET%E5%8F%82%E6%95%B0%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>当我们在SpringCloud项目中引入spring-cloud-starter-openfeign时，如果我们用Feign发送Get请求时，采用POJO对象传递参数，那么会可能会出现异常。那么如果你又不想用@RequestParam一个个参数写在调用方法内，有什么好的解决方案吗？</p></blockquote><p>下面是我在调用某个接口，GET请求：</p><pre><code class="java">@FeignClient(name = &quot;BiaoClient&quot;, url = &quot;${boss.biao.url}&quot;)public interface BiaoClient {    @GetMapping(&quot;/api/getDeviceStatus&quot;)    BiaoBaseResponse&lt;DeviceStatusInfo&gt; queryBiaoInfo(DeviceStatusInfoRequest request);}</code></pre><p>当发起调用的时候，会出现异常，大体意思是<code>Request method &#39;POST&#39; not supported</code>,为什么是POST请求呢？</p><p>究其原因是因为feign默认的远程调用使用的是jdk底层的HttpURLConnection，这在feign-core包下的Client接口中的convertAndSend方法可看到:</p><pre><code class="java"> if (request.body() != null) {        if (contentLength != null) {          connection.setFixedLengthStreamingMode(contentLength);        } else {          connection.setChunkedStreamingMode(8196);        }        connection.setDoOutput(true);        OutputStream out = connection.getOutputStream();        if (gzipEncodedRequest) {          out = new GZIPOutputStream(out);        } else if (deflateEncodedRequest) {          out = new DeflaterOutputStream(out);        }        try {          out.write(request.body());        } finally {          try {            out.close();          } catch (IOException suppressed) { // NOPMD          }        }      }</code></pre><p>该段代码片段会判断requestBody是否为空，我们知道GET请求默认是不会有requestBody的，因此该段代码会执行到HttpURLConnection中：</p><pre><code class="java"> private synchronized OutputStream getOutputStream0() throws IOException {        try {            if (!this.doOutput) {                throw new ProtocolException(&quot;cannot write to a URLConnection if doOutput=false - call setDoOutput(true)&quot;);            } else {                if (this.method.equals(&quot;GET&quot;)) {                    this.method = &quot;POST&quot;;                }</code></pre><p>最关键的代码片段已显示当请求方式为GET请求，会将该GET请求修改为POST请求，这也就是出现该异常的原因。</p><p>那么怎么解决呢?</p><p>当然如果你不用POJO的方式去传递出参数当然是可行的，如下：</p><pre><code class="java">@FeignClient(name = &quot;BiaoClient&quot;, url = &quot;${boss.biao.url}&quot;)public interface BiaoClient {    @GetMapping(&quot;/api/getDeviceStatus&quot;)    BiaoBaseResponse&lt;DeviceStatusInfo&gt; queryBiaoInfo(@RequestParam(&quot;sn&quot;) String sn,                                                       @RequestParam(&quot;ack&quot;) String ack);}</code></pre><p>如果想保持POJO作为参数？依然是有方案的。</p><h5 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h5><blockquote><p>目前网上搜索到的都是这个方案。</p></blockquote><p>我们只需将feign底层的远程调用由HttpURLConnection修改为其他远程调用方式即可，而且基本不需要修改太多的代码，这里利用apache的HttpClient。</p><ol><li><code>application.properties</code>加入<code>feign.httpclient.enabled=true</code></li><li>加入依赖</li></ol><pre><code class="xml">&lt;!-- 使用Apache HttpClient替换Feign原生httpclient --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;  &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;  &lt;version&gt;8.17.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><ol start="3"><li>需要@RequestBody，如下：</li></ol><pre><code class="java">@FeignClient(name = &quot;BiaoClient&quot;, url = &quot;${boss.biao.url}&quot;)public interface BiaoClient {    @GetMapping(&quot;/api/getDeviceStatus&quot;)    BiaoBaseResponse&lt;DeviceStatusInfo&gt; queryBiaoInfo(@RequestBody DeviceStatusInfoRequest request);}</code></pre><p><em>额外加一句，在GET方法里，加@RequestBody总感觉别扭。。。</em></p><h5 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h5><p>这个方案是Spring Cloud OpenFeign官方提供的，我是在看<a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign/2.1.0.RC3/single/spring-cloud-openfeign.html" target="_blank" rel="noopener">官方文档</a>看到的，于是在github上找查看了一下。</p><p><strong>这个方案更推荐使用</strong>！在github上有这样一个<a href="https://github.com/spring-cloud/spring-cloud-openfeign/pull/79/files" target="_blank" rel="noopener">Issue</a>——<code>Add support for feign&#39;s QueryMap annotation for Object mapping #79</code>,这个Issue已经是closed，看日期是解决是在2018-12-07号。方法也很简单。保持原来的不用改，不需要添加额外的依赖，加一个注解<code>@SpringQueryMap</code>就搞定。</p><pre><code class="java">@FeignClient(name = &quot;BiaoClient&quot;, url = &quot;${boss.biao.url}&quot;)public interface BiaoClient {    @GetMapping(&quot;/api/getDeviceStatus&quot;)    BiaoBaseResponse&lt;DeviceStatusInfo&gt; queryBiaoInfo(@SpringQueryMap DeviceStatusInfoRequest request);}</code></pre><p>下图是解决这个issue改变的代码：<br><img src="/2019/04/23/Spring-Cloud-OpenFeign支持POJO提作为GET参数映射/./Xnip2019-01-06_23-53-28.jpg" srcset="/img/loading.gif" alt="1"></p><p>注意，要用该注解，需要升级你的Spring Cloud OpenFeign到新的版本（<code>2.1.0.RC1</code>以及之后的版本）。</p>]]></content>
    
    
    
    <tags>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis mapper返回支持Optional</title>
    <link href="/2019/04/19/mybatis-mapper%E8%BF%94%E5%9B%9E%E6%94%AF%E6%8C%81Optional/"/>
    <url>/2019/04/19/mybatis-mapper%E8%BF%94%E5%9B%9E%E6%94%AF%E6%8C%81Optional/</url>
    
    <content type="html"><![CDATA[<blockquote><p>java8发布以来，带来了很多的新特性，其中<code>Optional</code>则旨在减少<code>NullPointException</code>，避免if条件的判空,提升了代码的美观度.然而2014年发布java8的很久之后，<code>mabatis</code>都没有很好的支持mapper中返回<code>Optional</code>。终于在<code>mybatis-3.5.0</code>(2019-01-21)中对该功能进行的支持！！！</p></blockquote><h4 id="一-mybatis-3-5-0"><a href="#一-mybatis-3-5-0" class="headerlink" title="一. mybatis-3.5.0"></a>一. mybatis-3.5.0</h4><ol><li><a href="https://github.com/mybatis/mybatis-3/releases" target="_blank" rel="noopener">mybatis-3.5.0更新记录</a><pre><code>Enhancements:Support java.util.Optional as return type of mapper method. #799...</code></pre></li></ol><h4 id="二-体验"><a href="#二-体验" class="headerlink" title="二. 体验"></a>二. 体验</h4><blockquote><p>springboot + mybatis</p><ol><li>pom.xml<br><code>`</code>xml</li></ol></blockquote><p><modelversion>4.0.0</modelversion><br>    <parent><br>        <groupid>org.springframework.boot</groupid><br>        <artifactid>spring-boot-starter-parent</artifactid><br>        <version>2.1.4.RELEASE</version><br>        <relativepath> <!-- lookup parent from repository --><br>    </relativepath></parent><br>    <groupid>com.justme</groupid><br>    <artifactid>mybatis-demo</artifactid><br>    <version>0.0.1-SNAPSHOT</version><br>    <name>mybatis-demo</name><br>    <description>Demo project for Spring Boot</description><br>    <properties><br>        &lt;java.version&gt;1.8&lt;/java.version&gt;<br>    </properties><br>    <dependencies><br>        <dependency><br>            <groupid>org.springframework.boot</groupid><br>            <artifactid>spring-boot-starter-validation</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework.boot</groupid><br>            <artifactid>spring-boot-starter-web</artifactid><br>        </dependency><br>        <dependency><br>            <groupid>org.mybatis.spring.boot</groupid><br>            <artifactid>mybatis-spring-boot-starter</artifactid><br>            <version>2.0.1</version><br>        </dependency><br>        <dependency><br>            <groupid>mysql</groupid><br>            <artifactid>mysql-connector-java</artifactid><br>            <scope>runtime</scope><br>        </dependency><br>        <dependency><br>            <groupid>org.projectlombok</groupid><br>            <artifactid>lombok</artifactid><br>            <optional>true</optional><br>        </dependency><br>        <dependency><br>            <groupid>org.springframework.boot</groupid><br>            <artifactid>spring-boot-starter-test</artifactid><br>            <scope>test</scope><br>        </dependency><br>        <!-- https://mvnrepository.com/artifact/org.mybatis/mybatis-typehandlers-jsr310 --><br>        <!--<dependency>--><br>            <!--<groupId>org.mybatis</groupId>--><br>            <!--<artifactId>mybatis-typehandlers-jsr310</artifactId>--><br>            <!--<version>1.0.2</version>--><br>        <!--</dependency>--><br>    </dependencies><br>    <build><br>        <plugins><br>            <plugin><br>                <groupid>org.springframework.boot</groupid><br>                <artifactid>spring-boot-maven-plugin</artifactid><br>            </plugin><br>        </plugins><br>    </build></p><pre><code>2. mapper```java@Mapperpublic interface CarApprovalMapper {    @Select(&quot;select * from car_approval where car_identify = #{carIdentify}&quot;)    Optional&lt;CarApproval&gt; getByCarIdentity(String carIdentify);    @Insert(&quot;insert into car_approval(car_identify, relation_no, user_id, user_name, remarks, create_time) values(#{carIdentify}, #{relationNo}, #{userId}, #{userName}, #{remarks}, #{createTime})&quot;)    int insert(CarApproval carApproval);}</code></pre><ol start="3"><li><p>测试<br><code>`</code>java<br>/**</p><ul><li><p>@date 2019/4/19 14:44<br>*/<br>@RunWith(SpringRunner.class)<br>@SpringBootTest<br>public class CarApprovalMapperTest {</p><p>@Autowired<br>private CarApprovalMapper carApprovalMapper;</p><p>@Test<br>public void getByCarIdentityTest() {<br>   Optional<carapproval> car = carApprovalMapper.getByCarIdentity(“”);<br>   Assert.assertEquals(car, Optional.empty());<br>}</carapproval></p><p>@Test<br>public void insertTest() {<br>   CarApproval carApproval = new CarApproval();<br>   carApproval.setCarIdentify(“dsfsdfsfdsfsdf”);<br>   carApproval.setUserId(111);<br>   carApproval.setUserName(“jack”);<br>   carApproval.setCreateTime(LocalDateTime.now());<br>   carApprovalMapper.insert(carApproval);<br>}</p></li></ul></li></ol><p>}<br>大家可以自己动手，跑一下测试，不过多演示了。</p><p><code>`</code></p><h4 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h4><p>经过测试，发现mybatis终于可以很爽的支持<code>mapper</code>的<code>Optional</code>的返回了，一起来体验<code>Optional</code>带来优雅便利吧！</p>]]></content>
    
    
    
    <tags>
      
      <tag>mybatis</tag>
      
      <tag>Optional</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
